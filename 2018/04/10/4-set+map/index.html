<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ES6 Set-Map"><meta name="keywords" content="es6"><meta name="author" content="ChengWei"><meta name="copyright" content="ChengWei"><title>ES6 Set-Map | Chengcw'博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Chengcw'博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. 集合（Set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WeakSet"><span class="toc-number">2.</span> <span class="toc-text">2. WeakSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E5%85%B8%EF%BC%88Map%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 字典（Map）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-WeakMap"><span class="toc-number">4.</span> <span class="toc-text">4. WeakMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">5. 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%A9%E5%B1%95%EF%BC%9AObject%E4%B8%8ESet%E3%80%81Map"><span class="toc-number">6.</span> <span class="toc-text">6. 扩展：Object与Set、Map</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://wx2.sinaimg.cn/thumb150/008soxMJly1h0v1m20khej30u00u0td0.jpg"></div><div class="author-info__name text-center">ChengWei</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/USERNAME">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">150</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F6%2F53cca8e7873e6.jpg&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664449271&amp;t=4f4642aaba02226ad62910f50b366e4b)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Chengcw'博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">ES6 Set-Map</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><ul>
<li><code>Set</code> 和 <code>Map</code> 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></li>
<li><code>Set</code> 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</li>
</ul>
<h3 id="1-集合（Set）"><a href="#1-集合（Set）" class="headerlink" title="1. 集合（Set）"></a>1. 集合（Set）</h3><blockquote>
<p><code>ES6</code> 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p>
</blockquote>
<p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set([iterable])</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set()</span><br><span class="line">[1, 2, 3, 4, 3, 2, 1].forEach(x =&gt; s.add(x))</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">    console.log(i)	// 1 2 3 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 去重数组的重复对象</span><br><span class="line">let arr = [1, 2, 3, 2, 1, 1]</span><br><span class="line">[... new Set(arr)]	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是 <strong>Set 认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set // Set &#123;NaN&#125;</span><br><span class="line"></span><br><span class="line">let set1 = new Set()</span><br><span class="line">set1.add(5)</span><br><span class="line">set1.add(&#x27;5&#x27;)</span><br><span class="line">console.log([...set1])	// [5, &quot;5&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Set 实例属性</p>
<ul>
<li><p>constructor： 构造函数</p>
</li>
<li><p>size：元素数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3, 2, 1])</span><br><span class="line"></span><br><span class="line">console.log(set.length)	// undefined</span><br><span class="line">console.log(set.size)	// 3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Set 实例方法</p>
<ul>
<li><p>操作方法</p>
<ul>
<li><p>add(value)：新增，相当于 array里的push</p>
</li>
<li><p>delete(value)：存在即删除集合中value</p>
</li>
<li><p>has(value)：判断集合中是否存在 value</p>
</li>
<li><p>clear()：清空集合</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set()</span><br><span class="line">set.add(1).add(2).add(1)</span><br><span class="line"></span><br><span class="line">set.has(1)	// true</span><br><span class="line">set.has(3)	// false</span><br><span class="line">set.delete(1)	</span><br><span class="line">set.has(1)	// false</span><br></pre></td></tr></table></figure>

<p><code>Array.from</code> 方法可以将 Set 结构转为数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 2])</span><br><span class="line">const array = Array.from(items)</span><br><span class="line">console.log(array)	// [1, 2, 3]</span><br><span class="line">// 或</span><br><span class="line">const arr = [...items]</span><br><span class="line">console.log(arr)	// [1, 2, 3]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历方法（遍历顺序为插入顺序）</p>
<ul>
<li><p>keys()：返回一个包含集合中所有键的迭代器</p>
</li>
<li><p>values()：返回一个包含集合中所有值得迭代器</p>
</li>
<li><p>entries()：返回一个包含Set对象中所有元素得键值对迭代器</p>
</li>
<li><p>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">console.log(set.keys())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.values())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line">console.log(set.entries())	// SetIterator &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// 1	2	 3</span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;	// [1, 1]	[2, 2]	[3, 3]</span><br><span class="line"></span><br><span class="line">set.forEach((value, key) =&gt;  &#123;</span><br><span class="line">    console.log(key + &#x27; : &#x27; + value)</span><br><span class="line">&#125;)	// 1 : 1	2 : 2		3 : 3</span><br><span class="line">console.log([...set])	// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values	// true</span><br></pre></td></tr></table></figure>

<p>所以， Set可以使用 map、filter 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3])</span><br><span class="line">set = new Set([...set].map(item =&gt; item * 2))</span><br><span class="line">console.log([...set])	// [2, 4, 6]</span><br><span class="line"></span><br><span class="line">set = new Set([...set].filter(item =&gt; (item &gt;= 4)))</span><br><span class="line">console.log([...set])	//[4, 6]</span><br></pre></td></tr></table></figure>

<p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let set1 = new Set([1, 2, 3])</span><br><span class="line">let set2 = new Set([4, 3, 2])</span><br><span class="line"></span><br><span class="line">let intersect = new Set([...set1].filter(value =&gt; set2.has(value)))</span><br><span class="line">let union = new Set([...set1, ...set2])</span><br><span class="line">let difference = new Set([...set1].filter(value =&gt; !set2.has(value)))</span><br><span class="line"></span><br><span class="line">console.log(intersect)	// Set &#123;2, 3&#125;</span><br><span class="line">console.log(union)		// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">console.log(difference)	// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h3><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p>
<p>WeakSet 与 Set 的区别：</p>
<ul>
<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>
</ul>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [[1, 2], [3, 4]]</span><br><span class="line">const weakset = new WeakSet(arr)</span><br><span class="line">console.log(weakset)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/19721451/54000905-3d36c980-4184-11e9-9ccf-0f13bc6dd414.png" alt="2019-03-08 9 24 34"></p>
<p>方法：</p>
<ul>
<li>add(value)：在WeakSet 对象中添加一个元素value</li>
<li>has(value)：判断 WeakSet 对象中是否包含value</li>
<li>delete(value)：删除元素 value</li>
<li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WeakSet()</span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">var foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(window)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(window)	// true</span><br><span class="line">ws.has(foo)	// false</span><br><span class="line"></span><br><span class="line">ws.delete(window)	// true</span><br><span class="line">ws.has(window)	// false</span><br></pre></td></tr></table></figure>

<h3 id="3-字典（Map）"><a href="#3-字典（Map）" class="headerlink" title="3. 字典（Map）"></a>3. 字典（Map）</h3><p>集合 与 字典 的区别：</p>
<ul>
<li>共同点：集合、字典 可以储存不重复的值</li>
<li>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map()</span><br><span class="line">const o = &#123;p: &#x27;haha&#x27;&#125;</span><br><span class="line">m.set(o, &#x27;content&#x27;)</span><br><span class="line">m.get(o)	// content</span><br><span class="line"></span><br><span class="line">m.has(o)	// true</span><br><span class="line">m.delete(o)	// true</span><br><span class="line">m.has(o)	// false</span><br></pre></td></tr></table></figure>

<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([</span><br><span class="line">  [&#x27;foo&#x27;, 1],</span><br><span class="line">  [&#x27;bar&#x27;, 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(set);</span><br><span class="line">m1.get(&#x27;foo&#x27;) // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([[&#x27;baz&#x27;, 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.get(&#x27;baz&#x27;) // 3</span><br></pre></td></tr></table></figure>

<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Map().get(&#x27;asfddfsasadf&#x27;)</span><br><span class="line">// undefined</span><br></pre></td></tr></table></figure>

<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&#x27;a&#x27;], 555);</span><br><span class="line">map.get([&#x27;a&#x27;]) // undefined</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br><span class="line"></span><br><span class="line">map.set(true, 1);</span><br><span class="line">map.set(&#x27;true&#x27;, 2);</span><br><span class="line">map.get(true) // 1</span><br><span class="line"></span><br><span class="line">map.set(undefined, 3);</span><br><span class="line">map.set(null, 4);</span><br><span class="line">map.get(undefined) // 3</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>

<p>Map 的属性及方法</p>
<p>属性：</p>
<ul>
<li><p>constructor：构造函数</p>
</li>
<li><p>size：返回字典中所包含的元素个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">  [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">  [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size // 2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>操作方法：</p>
<ul>
<li>set(key, value)：向字典中添加新元素</li>
<li>get(key)：通过键查找特定的数值并返回</li>
<li>has(key)：判断字典中是否存在键key</li>
<li>delete(key)：通过键 key 从字典中移除对应的数据</li>
<li>clear()：将这个字典中的所有元素删除</li>
</ul>
<p>遍历方法</p>
<ul>
<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>
<li>values()：将字典中包含的所有数值以迭代器形式返回</li>
<li>entries()：返回所有成员的迭代器</li>
<li>forEach()：遍历字典的所有成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">            [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">            [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">        ]);</span><br><span class="line">console.log(map.entries())	// MapIterator &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br><span class="line">console.log(map.keys()) // MapIterator &#123;&quot;name&quot;, &quot;des&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[Symbol.iterator] === map.entries</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>

<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>
<p>对于 forEach ，看一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const reporter = &#123;</span><br><span class="line">  report: function(key, value) &#123;</span><br><span class="line">    console.log(&quot;Key: %s, Value: %s&quot;, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let map = new Map([</span><br><span class="line">    [&#x27;name&#x27;, &#x27;An&#x27;],</span><br><span class="line">    [&#x27;des&#x27;, &#x27;JS&#x27;]</span><br><span class="line">])</span><br><span class="line">map.forEach(function(value, key, map) &#123;</span><br><span class="line">  this.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br><span class="line">// Key: name, Value: An</span><br><span class="line">// Key: des, Value: JS</span><br></pre></td></tr></table></figure>

<p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p>
<p><strong>与其他数据结构的相互转换</strong></p>
<ol>
<li><p>Map 转 Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log([...map])	// [[1, 1], [2, 2], [3, 3]]</span><br></pre></td></tr></table></figure></li>
<li><p>Array 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[1, 1], [2, 2], [3, 3]])</span><br><span class="line">console.log(map)	// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Map 转 Object</p>
<p>因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function mapToObj(map) &#123;</span><br><span class="line">    let obj = Object.create(null)</span><br><span class="line">    for (let [key, value] of map) &#123;</span><br><span class="line">        obj[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">const map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToObj(map) // &#123;name: &quot;An&quot;, des: &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Object 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function objToMap(obj) &#123;</span><br><span class="line">    let map = new Map()</span><br><span class="line">    for (let key of Object.keys(obj)) &#123;</span><br><span class="line">        map.set(key, obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123;&#x27;name&#x27;: &#x27;An&#x27;, &#x27;des&#x27;: &#x27;JS&#x27;&#125;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Map 转 JSON</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function mapToJson(map) &#123;</span><br><span class="line">    return JSON.stringify([...map])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let map = new Map().set(&#x27;name&#x27;, &#x27;An&#x27;).set(&#x27;des&#x27;, &#x27;JS&#x27;)</span><br><span class="line">mapToJson(map)	// [[&quot;name&quot;,&quot;An&quot;],[&quot;des&quot;,&quot;JS&quot;]]</span><br></pre></td></tr></table></figure></li>
<li><p>JSON 转 Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function jsonToStrMap(jsonStr) &#123;</span><br><span class="line">  return objToMap(JSON.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(&#x27;&#123;&quot;name&quot;: &quot;An&quot;, &quot;des&quot;: &quot;JS&quot;&#125;&#x27;) // Map &#123;&quot;name&quot; =&gt; &quot;An&quot;, &quot;des&quot; =&gt; &quot;JS&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>
<p>属性：</p>
<ul>
<li>constructor：构造函数</li>
</ul>
<p>方法：</p>
<ul>
<li>has(key)：判断是否有 key 关联对象</li>
<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>
<li>set(key)：设置一组key关联对象</li>
<li>delete(key)：移除 key 的关联对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myElement = document.getElementById(&#x27;logo&#x27;);</span><br><span class="line">let myWeakmap = new WeakMap();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">  let logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h3 id="6-扩展：Object与Set、Map"><a href="#6-扩展：Object与Set、Map" class="headerlink" title="6. 扩展：Object与Set、Map"></a>6. 扩展：Object与Set、Map</h3><ol>
<li><p>Object 与 Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Object</span><br><span class="line">const properties1 = &#123;</span><br><span class="line">    &#x27;width&#x27;: 1,</span><br><span class="line">    &#x27;height&#x27;: 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(properties1[&#x27;width&#x27;]? true: false) // true</span><br><span class="line"></span><br><span class="line">// Set</span><br><span class="line">const properties2 = new Set()</span><br><span class="line">properties2.add(&#x27;width&#x27;)</span><br><span class="line">properties2.add(&#x27;height&#x27;)</span><br><span class="line">console.log(properties2.has(&#x27;width&#x27;)) // true</span><br></pre></td></tr></table></figure></li>
<li><p>Object 与 Map</p>
</li>
</ol>
<p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;&#125;;</span><br><span class="line">const element = document.getElementsByClassName(&#x27;App&#x27;);</span><br><span class="line"></span><br><span class="line">data[element] = &#x27;metadata&#x27;;</span><br><span class="line">console.log(data[&#x27;[object HTMLCollection]&#x27;]) // &quot;metadata&quot;</span><br></pre></td></tr></table></figure>

<p>但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map则提供了 <strong>值-值</strong> 的对应</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ChengWei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2018/04/10/4-set+map/">http://example.com/2018/04/10/4-set+map/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/es6/">es6</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/12/4-Symbol/"><i class="fa fa-chevron-left">  </i><span>ES6 Symbol</span></a></div><div class="next-post pull-right"><a href="/2018/04/07/4-Reflect/"><span>ES6 Reflect</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F6%2F53cca8e7873e6.jpg&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664449271&amp;t=4f4642aaba02226ad62910f50b366e4b)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By ChengWei</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>