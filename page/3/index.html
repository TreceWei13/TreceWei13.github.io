<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="ChengWei"><meta name="copyright" content="ChengWei"><title>Chengcw'博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Chengcw'博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://wx2.sinaimg.cn/thumb150/008soxMJly1h0v1m20khej30u00u0td0.jpg"></div><div class="author-info__name text-center">ChengWei</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/USERNAME">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">150</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><nav id="nav" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F6%2F53cca8e7873e6.jpg&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664449271&amp;t=4f4642aaba02226ad62910f50b366e4b)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Chengcw'博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Chengcw'博客</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/Molunerfinn" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fa"></i></a><a class="social-icon" href="http://weibo.com/mybluedreams" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-weibo fa"></i></a><a class="social-icon" href="https://Molunerfinn/atom.xml" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-rss fa"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/03/React-Jsx%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9C%9F%E5%AE%9EDOM%E8%BF%87%E7%A8%8B/">React-Jsx转换成真实DOM过程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/React/">React</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>react</code>通过将组件编写的<code>JSX</code>映射到屏幕，以及组件中的状态发生了变化之后 <code>React</code>会将这些「变化」更新到屏幕上</p>
<p><code>JSX</code>通过<code>babel</code>最终转化成<code>React.createElement</code>这种形式，例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt; img src=<span class="string">&quot;avatar.png&quot;</span> className=<span class="string">&quot;profile&quot;</span> /&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>会被<code>bebel</code>转化成如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">src</span>: <span class="string">&quot;avatar.png&quot;</span>,</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;profile&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Hello</span>, <span class="literal">null</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在转化过程中，<code>babel</code>在编译时会判断 JSX 中组件的首字母：</p>
<ul>
<li>当首字母为小写时，其被认定为原生 <code>DOM</code> 标签，<code>createElement</code> 的第一个变量被编译为字符串</li>
<li>当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象</li>
</ul>
<p>最终都会通过<code>RenderDOM.render(...)</code>方法进行挂载，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h2><p>在<code>react</code>中，节点大致可以分成四个类别：</p>
<ul>
<li>原生标签节点</li>
<li>文本节点</li>
<li>函数组件</li>
<li>类组件</li>
</ul>
<p>如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;pink&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&quot;border&quot;&gt;</span><br><span class="line">        &lt;h3&gt;ClassComponent&lt;/h3&gt;</span><br><span class="line">        &lt;p className=&#123;this.props.color&#125;&gt;&#123;this.props.name&#125;&lt;/p &gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function FunctionComponent(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;border&quot;&gt;</span><br><span class="line">      FunctionComponent</span><br><span class="line">      &lt;p&gt;&#123;props.name&#125;&lt;/p &gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const jsx = (</span><br><span class="line">  &lt;div className=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;xx&lt;/p &gt;</span><br><span class="line">    &lt; a href=&quot; &quot;&gt;xxx&lt;/ a&gt;</span><br><span class="line">    &lt;FunctionComponent name=&quot;函数组件&quot; /&gt;</span><br><span class="line">    &lt;ClassComponent name=&quot;类组件&quot; color=&quot;red&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这些类别最终都会被转化成<code>React.createElement</code>这种形式</p>
<p><code>React.createElement</code>其被调用时会传⼊标签类型<code>type</code>，标签属性<code>props</code>及若干子元素<code>children</code>，作用是生成一个虚拟<code>Dom</code>对象，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, ...children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config) &#123;</span><br><span class="line">        <span class="keyword">delete</span> config.<span class="property">__self</span>;</span><br><span class="line">        <span class="keyword">delete</span> config.<span class="property">__source</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 源码中做了详细处理，⽐如过滤掉key、ref等</span></span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">   <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : <span class="title function_">createTextNode</span>(child)</span><br><span class="line">  )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextNode</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">TEXT</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">children</span>: [],</span><br><span class="line">            <span class="attr">nodeValue</span>: text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    createElement</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>createElement</code>会根据传入的节点信息进行一个判断：</p>
<ul>
<li>如果是原生标签节点， type 是字符串，如div、span</li>
<li>如果是文本节点， type就没有，这里是 TEXT</li>
<li>如果是函数组件，type 是函数名</li>
<li>如果是类组件，type 是类名</li>
</ul>
<p>虚拟<code>DOM</code>会通过<code>ReactDOM.render</code>进行渲染成真实<code>DOM</code>，使用方法如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, container[, callback])</span><br></pre></td></tr></table></figure>

<p>当首次调用时，容器节点里的所有 <code>DOM</code> 元素都会被替换，后续的调用则会使用 <code>React</code> 的 <code>diff</code>算法进行高效的更新</p>
<p>如果提供了可选的回调函数<code>callback</code>，该回调将在组件被渲染或更新之后被执行</p>
<p><code>render</code>大致实现方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnode&quot;</span>, vnode); <span class="comment">// 虚拟DOM对象</span></span><br><span class="line">    <span class="comment">// vnode _&gt; node</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vnode, container);</span><br><span class="line">    container.<span class="title function_">appendChild</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建真实DOM节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNode</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="variable constant_">TEXT</span>) &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        node = type.<span class="property">isReactComponent</span></span><br><span class="line">            ? <span class="title function_">updateClassComponent</span>(vnode, parentNode)</span><br><span class="line">        : <span class="title function_">updateFunctionComponent</span>(vnode, parentNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reconcileChildren</span>(props.<span class="property">children</span>, node);</span><br><span class="line">    <span class="title function_">updateNode</span>(node, props);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历下子vnode，然后把子vnode-&gt;真实DOM节点，再插入父node中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">children, node</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> child = children[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(child)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; child.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="title function_">render</span>(child[j], node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">render</span>(child, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateNode</span>(<span class="params">node, nextVal</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextVal)</span><br><span class="line">        .<span class="title function_">filter</span>(<span class="function"><span class="params">k</span> =&gt;</span> k !== <span class="string">&quot;children&quot;</span>)</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eventName = k.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLocaleLowerCase</span>();</span><br><span class="line">            node.<span class="title function_">addEventListener</span>(eventName, nextVal[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node[k] = nextVal[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回真实dom节点</span></span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">let</span> vvnode = <span class="title function_">type</span>(props);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vvnode, parentNode);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回真实dom节点</span></span><br><span class="line"><span class="comment">// 先实例化，再执行render函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">let</span> cmp = <span class="keyword">new</span> <span class="title function_">type</span>(props);</span><br><span class="line">    <span class="keyword">const</span> vvnode = cmp.<span class="title function_">render</span>();</span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vvnode, parentNode);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    render</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在<code>react</code>源码中，虚拟<code>Dom</code>转化成真实<code>Dom</code>整体流程如下图所示：</p>
<p><img src="https://static.vue-js.com/28824fa0-f00a-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>其渲染流程如下所示：</p>
<ul>
<li>使用React.createElement或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(…) ，Babel帮助我们完成了这个转换的过程。</li>
<li>createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象</li>
<li>ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/18/React-%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E6%95%88%E7%8E%87%20%20%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84render/">React-提高组件效率  避免不必要的render</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p><code>react</code> 基于虚拟 <code>DOM</code> 和高效 <code>Diff</code>算法的完美配合，实现了对 <code>DOM</code>最小粒度的更新，大多数情况下，<code>React</code>对 <code>DOM</code>的渲染效率足以我们的业务日常</p>
<p>复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，避免不必要的渲染则是业务中常见的优化手段之一</p>
<h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p>在之前文章中，我们了解到<code>render</code>的触发时机，简单来讲就是类组件通过调用<code>setState</code>方法， 就会导致<code>render</code>，父组件一旦发生<code>render</code>渲染，子组件一定也会执行<code>render</code>渲染</p>
<p>从上面可以看到，父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p>
<ul>
<li>shouldComponentUpdate</li>
<li>PureComponent</li>
<li>React.memo</li>
</ul>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>通过<code>shouldComponentUpdate</code>生命周期函数来比对 <code>state</code>和 <code>props</code>，确定是否要重新渲染</p>
<p>默认情况下返回<code>true</code>表示重新渲染，如果不希望组件重新渲染，返回 <code>false</code> 即可</p>
<h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>跟<code>shouldComponentUpdate</code>原理基本一致，通过对 <code>props</code> 和 <code>state</code>的浅比较结果来实现 <code>shouldComponentUpdate</code>，源码大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_compositeType</span> === <span class="title class_">CompositeTypes</span>.<span class="property">PureClass</span>) &#123;</span><br><span class="line">    shouldUpdate = !<span class="title function_">shallowEqual</span>(prevProps, nextProps) || ! <span class="title function_">shallowEqual</span>(inst.<span class="property">state</span>, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shallowEqual</code>对应方法大致如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is 方法来判断两个值是否是相等的值，为何这么写可以移步 MDN 的文档</span></span><br><span class="line"><span class="comment"> * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">is</span>(<span class="params">x: mixed, y: mixed</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): boolean &#123;</span><br><span class="line">  <span class="comment">// 首先对基本类型进行比较</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">is</span>(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> || objA === <span class="literal">null</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> || objB === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 长度不相等直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key相等的情况下，再去循环比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.<span class="title function_">call</span>(objB, keysA[i]) ||</span><br><span class="line">      !<span class="title function_">is</span>(objA[keysA[i]], objB[keysA[i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象包含复杂的数据结构时，对象深层的数据已改变却没有触发 <code>render</code></p>
<p>注意：在<code>react</code>中，是不建议使用深层次结构的数据</p>
<h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p><code>React.memo</code>用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 <code>PureComponent</code> 十分类似。但不同的是， <code>React.memo</code> 只能用于函数组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// Component code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Button</span>);</span><br></pre></td></tr></table></figure>

<p>如果需要深层次比较，这时候可以给<code>memo</code>第二个参数传递比较函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arePropsEqual</span>(<span class="params">prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">// your code</span></span><br><span class="line">  <span class="keyword">return</span> prevProps === nextProps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Button</span>, arePropsEqual);</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在实际开发过程中，前端性能问题是一个必须考虑的问题，随着业务的复杂，遇到性能问题的概率也在增高</p>
<p>除此之外，建议将页面进行更小的颗粒化，如果一个过大，当状态发生修改的时候，就会导致整个大组件的渲染，而对组件进行拆分后，粒度变小了，也能够减少子组件不必要的渲染</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/15/React-hooks/">React hooks</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、组件类的缺点"><a href="#一、组件类的缺点" class="headerlink" title="一、组件类的缺点"></a>一、组件类的缺点</h2><blockquote>
<p><code>React</code> 的核心是组件。<code>v16.8</code>版本之前，组件的标准写法是类（class）。下面是一个简单的组件类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class Button extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123; buttonText: &quot;Click me, please&quot; &#125;;</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(() =&gt; &#123;</span><br><span class="line">      return &#123; buttonText: &quot;Thanks, been clicked!&quot; &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; buttonText &#125; = this.state;</span><br><span class="line">    return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个组件类仅仅是一个按钮，但可以看到，它的代码已经很”重”了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂</p>
<p><code>Hook</code> 是 React 16.8 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性</p>
<p>至于为什么引入<code>hook</code>，官方给出的动机是解决长时间使用和维护<code>react</code>过程中常遇到的问题，例如：</p>
<ul>
<li>难以重用和共享组件中的与状态相关的逻辑</li>
<li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</li>
<li>类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题</li>
<li>由于业务变动，函数组件不得不改为类组件等等</li>
</ul>
<p>在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作</p>
<p>因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理</p>
<h2 id="二、Hook-的含义"><a href="#二、Hook-的含义" class="headerlink" title="二、Hook 的含义"></a>二、Hook 的含义</h2><ul>
<li><code>React Hooks</code> 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 <code>React Hooks</code> 就是那些钩子。</li>
<li>你需要什么功能，就使用什么钩子。<code>React</code> 默认提供了一些常用钩子，你也可以封装自己的钩子。</li>
<li>所有的钩子都是为函数引入外部功能，所以 <code>React</code> 约定，钩子一律使用use前缀命名，便于识别。你要使用 <code>xxx</code> 功能，钩子就命名为 <code>usexxx</code></li>
</ul>
<p><strong>React 默认提供的四个最常用的钩子</strong></p>
<ul>
<li><code>useState()</code></li>
<li><code>useContext()</code></li>
<li><code>useReducer()</code></li>
<li><code>useEffect()</code></li>
<li><code>useCallback</code></li>
<li><code>useMemo</code></li>
</ul>
<h2 id="三、useState-：状态钩子"><a href="#三、useState-：状态钩子" class="headerlink" title="三、useState()：状态钩子"></a>三、useState()：状态钩子</h2><blockquote>
<p><code>useState()</code>用于为函数组件引入状态（<code>state</code>）。纯函数不能有状态，所以把状态放在钩子里面。</p>
</blockquote>
<p>用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用<code>useState()</code>重写如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default function  Button()  &#123;</span><br><span class="line">  const  [buttonText, setButtonText] =  useState(&quot;Click me,   please&quot;);</span><br><span class="line"></span><br><span class="line">  function handleClick()  &#123;</span><br><span class="line">    return setButtonText(&quot;Thanks, been clicked!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return  &lt;button  onClick=&#123;handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Button 组件是一个函数，内部使用useState()钩子引入状态。</p>
<blockquote>
<p><code>useState()</code>这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。该函数返回一个数组，数组的第一个成员是一个变量（上例是<code>buttonText</code>），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是set前缀加上状态的变量名（上例是<code>setButtonText</code>）</p>
</blockquote>
<h2 id="四、useContext-：共享状态钩子"><a href="#四、useContext-：共享状态钩子" class="headerlink" title="四、useContext()：共享状态钩子"></a>四、useContext()：共享状态钩子</h2><ul>
<li>如果需要在组件之间共享状态，可以使用·useContext()·。</li>
<li>现在有两个组件 ·Navbar ·和 ·Messages·，我们希望它们之间共享状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">  &lt;Navbar/&gt;</span><br><span class="line">  &lt;Messages/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一步就是使用 <code>React Context API</code>，在组件外部建立一个 <code>Context</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const AppContext = React.createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>组件封装代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;AppContext.Provider value=&#123;&#123;</span><br><span class="line">  username: &#x27;superawesome&#x27;</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">  &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">    &lt;Navbar/&gt;</span><br><span class="line">    &lt;Messages/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/AppContext.Provider&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，<code>AppContext.Provider</code>提供了一个 <code>Context</code> 对象，这个对象可以被子组件共享。</p>
</blockquote>
<p>Navbar 组件的代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Navbar = () =&gt; &#123;</span><br><span class="line">  const &#123; username &#125; = useContext(AppContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;navbar&quot;&gt;</span><br><span class="line">      &lt;p&gt;AwesomeSite&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;&#123;username&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，<code>useContext()</code>钩子函数用来引入<code>Context</code> 对象，从中获取<code>username</code>属性。</p>
</blockquote>
<p>Message 组件的代码也类似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Messages = () =&gt; &#123;</span><br><span class="line">  const &#123; username &#125; = useContext(AppContext)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;messages&quot;&gt;</span><br><span class="line">      &lt;h1&gt;Messages&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;1 message for &#123;username&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p className=&quot;message&quot;&gt;useContext is awesome!&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、useReducer-：action-钩子"><a href="#五、useReducer-：action-钩子" class="headerlink" title="五、useReducer()：action 钩子"></a>五、useReducer()：action 钩子</h2><ul>
<li>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</li>
<li>Redux 的核心概念是，组件发出 <code>action</code> 与状态管理器通信。状态管理器收到 <code>action</code>以后，使用 <code>Reducer</code>函数算出新的状态，<code>Reducer</code> 函数的形式是<code>(state, action) =&gt; newState</code>。</li>
<li><code>useReducers()</code>钩子用来引入 <code>Reducer</code> 功能。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialState);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面是<code>useReducer()</code>的基本用法，它接受<code>Reducer</code> 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 <code>action</code> 的<code>dispatch</code>函数。</p>
</blockquote>
<p>下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const myReducer = (state, action) =&gt; &#123;</span><br><span class="line">  switch(action.type)  &#123;</span><br><span class="line">    case(&#x27;countUp&#x27;):</span><br><span class="line">      return  &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    default:</span><br><span class="line">      return  state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">  const [state, dispatch] = useReducer(myReducer, &#123; count:   0 &#125;);</span><br><span class="line">  return  (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;countUp&#x27; &#125;)&#125;&gt;</span><br><span class="line">        +1</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux</p>
</blockquote>
<h2 id="六、useEffect-：副作用钩子"><a href="#六、useEffect-：副作用钩子" class="headerlink" title="六、useEffect()：副作用钩子"></a>六、useEffect()：副作用钩子</h2><blockquote>
<p><code>useEffect()</code>用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在<code>componentDidMount</code>里面的代码，现在可以放在<code>useEffect()</code>。</p>
</blockquote>
<p><code>useEffect()</code>的用法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()  =&gt;  &#123;</span><br><span class="line">  // Async Action</span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面用法中，<code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Person = (&#123; personId &#125;) =&gt; &#123;</span><br><span class="line">  const [loading, setLoading] = useState(true);</span><br><span class="line">  const [person, setPerson] = useState(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setLoading(true); </span><br><span class="line">    fetch(`https://swapi.co/api/people/$&#123;personId&#125;/`)</span><br><span class="line">      .then(response =&gt; response.json())</span><br><span class="line">      .then(data =&gt; &#123;</span><br><span class="line">        setPerson(data);</span><br><span class="line">        setLoading(false);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId])</span><br><span class="line"></span><br><span class="line">  if (loading === true) &#123;</span><br><span class="line">    return &lt;p&gt;Loading ...&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;p&gt;You&#x27;re viewing: &#123;person.name&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Height: &#123;person.height&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Mass: &#123;person.mass&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，每当组件参数<code>personId</code>发生变化，<code>useEffect()</code>就会执行。组件第一次渲染时，<code>useEffect()</code>也会执行</p>
</blockquote>
<h2 id="七、解决什么"><a href="#七、解决什么" class="headerlink" title="七、解决什么"></a>七、解决什么</h2><p>通过对上面的初步认识，可以看到<code>hooks</code>能够更容易解决状态相关的重用的问题：</p>
<ul>
<li>每调用useHook一次都会生成一份独立的状态</li>
<li>通过自定义hook能够更好的封装我们的功能</li>
</ul>
<p>编写<code>hooks</code>为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hooks`的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用`hooks`能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑`hooks</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/07/React-Fiber/">React Fiber</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><blockquote>
<p><code>React Fiber</code>是对核心算法的一次重新实现。<code>React Fiber</code>把更新过程碎片化，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会</p>
</blockquote>
<ol>
<li>在<code>React Fiber</code>中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来</li>
<li>因为一个更新过程可能被打断，所以<code>React Fiber</code>一个更新过程被分为两个阶段(<code>Phase</code>)：第一个阶段<code>Reconciliation Phase</code>和第二阶段<code>Commit Phase</code></li>
<li>在第一阶段<code>Reconciliation Phase</code>，<code>React Fiber</code>会找出需要更新哪些<code>DOM</code>，这个阶段是可以被打断的；但是到了第二阶段<code>Commit Phase</code>，那就一鼓作气把<code>DOM</code>更新完，绝不会被打断</li>
<li>这两个阶段大部分工作都是<code>React Fiber</code>做，和我们相关的也就是生命周期函数</li>
</ol>
<blockquote>
<p><code>React Fiber</code>改变了之前<code>react</code>的组件渲染机制，新的架构使原来同步渲染的组件现在可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程</p>
</blockquote>
<p><strong>关键特性</strong></p>
<ul>
<li>增量渲染（把渲染任务拆分成块，匀到多帧）</li>
<li>更新时能够暂停，终止，复用渲染任务</li>
<li>给不同类型的更新赋予优先级</li>
<li>并发方面新的基础能力</li>
</ul>
<blockquote>
<p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用</p>
</blockquote>
<h2 id="二、组件的渲染顺序"><a href="#二、组件的渲染顺序" class="headerlink" title="二、组件的渲染顺序"></a>二、组件的渲染顺序</h2><blockquote>
<p>假如有A,B,C,D组件，层级结构为：</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/414.png" alt="img"></p>
<p>我们知道组件的生命周期为：</p>
<p><strong>挂载阶段</strong>：</p>
<ul>
<li><code>constructor()</code></li>
<li><code>componentWillMount()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<p><strong>更新阶段为</strong>：</p>
<ul>
<li><code>componentWillReceiveProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>componentWillUpdate()</code></li>
<li><code>render()</code></li>
<li><code>componentDidUpdate</code></li>
</ul>
<blockquote>
<p>那么在挂载阶段，<code>A,B,C,D</code>的生命周期渲染顺序是如何的呢？</p>
</blockquote>
<p>那么在挂载阶段，A,B,C,D的生命周期渲染顺序是如何的呢？</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/415.png" alt="img"></p>
<blockquote>
<p>以<code>render()</code>函数为分界线。从顶层组件开始，一直往下，直至最底层子组件。然后再往上</p>
</blockquote>
<p>组件<code>update</code>阶段同理</p>
<p>前面是<code>react16</code>以前的组建渲染方式。这就存在一个问题</p>
<blockquote>
<p>如果这是一个很大，层级很深的组件，<code>react</code>渲染它需要几十甚至几百毫秒，在这期间，<code>react</code>会一直占用浏览器主线程，任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行</p>
</blockquote>
<p><strong>Fiber架构就是为了解决这个问题</strong></p>
<blockquote>
<p>看一下fiber架构 组建的渲染顺序</p>
</blockquote>
<blockquote>
<p>加入<code>fiber</code>的<code>react</code>将组件更新分为两个时期</p>
</blockquote>
<p><strong>这两个时期以render为分界</strong></p>
<ul>
<li><code>render</code>前的生命周期为<code>phase1</code>,</li>
<li><code>render</code>后的生命周期为<code>phase2</code></li>
</ul>
<blockquote>
<ul>
<li><code>phase1</code>的生命周期是可以被打断的，每隔一段时间它会跳出当前渲染进程，去确定是否有其他更重要的任务。此过程，<code>React</code>在 <code>workingProgressTree</code> （并不是真实的<code>virtualDomTree</code>）上复用 <code>current</code> 上的 <code>Fiber</code> 数据结构来一步地（通过<code>requestIdleCallback</code>）来构建新的 tree，标记处需要更新的节点，放入队列中</li>
<li><code>phase2</code>的生命周期是不可被打断的，<code>React</code> 将其所有的变更一次性更新到<code>DOM</code>上</li>
</ul>
</blockquote>
<p><strong>这里最重要的是phase1这是时期所做的事。因此我们需要具体了解phase1的机制</strong></p>
<ul>
<li>如果不被打断，那么<code>phase1</code>执行完会直接进入<code>render</code>函数，构建真实的<code>virtualDomTree</code></li>
<li>如果组件再<code>phase1</code>过程中被打断，即当前组件只渲染到一半（也许是在<code>willMount</code>,也许是<code>willUpdate</code>~反正是在render之前的生命周期），那么<code>react</code>会怎么干呢？ <code>react</code>会放弃当前组件所有干到一半的事情，去做更高优先级更重要的任务（当然，也可能是用户鼠标移动，或者其他react监听之外的任务），当所有高优先级任务执行完之后，<code>react</code>通过<code>callback</code>回到之前渲染到一半的组件，从头开始渲染。（看起来放弃已经渲染完的生命周期，会有点不合理，反而会增加渲染时长，但是<code>react</code>确实是这么干的）</li>
</ul>
<p><strong>所有phase1的生命周期函数都可能被执行多次，因为可能会被打断重来</strong></p>
<blockquote>
<p>这样的话，就和<code>react16</code>版本之前有很大区别了，因为可能会被执行多次，那么我们最好就得保证<code>phase1</code>的生命周期每一次执行的结果都是一样的，否则就会有问题，因此，最好都是纯函数</p>
</blockquote>
<ul>
<li>如果高优先级的任务一直存在，那么低优先级的任务则永远无法进行，组件永远无法继续渲染。这个问题facebook目前好像还没解决</li>
<li>所以，facebook在<code>react16</code>增加<code>fiber</code>结构，其实并不是为了减少组件的渲染时间，事实上也并不会减少，最重要的是现在可以使得一些更高优先级的任务，如用户的操作能够优先执行，提高用户的体验，至少用户不会感觉到卡顿</li>
</ul>
<h2 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h2><p><code>JavaScript</code>引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待</p>
<p>如果 <code>JavaScript</code> 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿</p>
<p>而这也正是 <code>React 15</code> 的 <code>Stack Reconciler</code>所面临的问题，当 <code>React</code>在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断</p>
<p>如果组件较大，那么<code>js</code>线程会一直执行，然后等到整棵<code>VDOM</code>树计算完成后，才会交给渲染的线程</p>
<p>这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况</p>
<p><img src="https://static.vue-js.com/5eb3a850-ed24-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<h2 id="二、是什么"><a href="#二、是什么" class="headerlink" title="二、是什么"></a>二、是什么</h2><p>React Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从Facebook在 React Conf 2017 会议上确认，React Fiber 在React 16 版本发布</p>
<p>在<code>react</code>中，主要做了以下的操作：</p>
<ul>
<li>为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li>增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li>dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
</ul>
<p>从架构角度来看，<code>Fiber</code> 是对 <code>React</code>核心算法（即调和过程）的重写</p>
<p>从编码角度来看，<code>Fiber</code>是 <code>React</code>内部所定义的一种数据结构，它是 <code>Fiber</code>树结构的节点单位，也就是 <code>React 16</code> 新架构下的虚拟<code>DOM</code></p>
<p>一个 <code>fiber</code>就是一个 <code>JavaScript</code>对象，包含了元素的信息、该元素的更新操作队列、类型，其数据结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Fiber</span> = &#123;</span><br><span class="line">  <span class="comment">// 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等</span></span><br><span class="line">  <span class="attr">tag</span>: <span class="title class_">WorkTag</span>,</span><br><span class="line">  <span class="comment">// ReactElement里面的key</span></span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span> | string,</span><br><span class="line">  <span class="comment">// ReactElement.type，调用`createElement`的第一个参数</span></span><br><span class="line">  <span class="attr">elementType</span>: any,</span><br><span class="line">  <span class="comment">// The resolved function/class/ associated with this fiber.</span></span><br><span class="line">  <span class="comment">// 表示当前代表的节点类型</span></span><br><span class="line">  <span class="attr">type</span>: any,</span><br><span class="line">  <span class="comment">// 表示当前FiberNode对应的element组件实例</span></span><br><span class="line">  <span class="attr">stateNode</span>: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">  <span class="attr">return</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line">  <span class="attr">child</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span></span><br><span class="line">  <span class="attr">sibling</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">index</span>: number,</span><br><span class="line"></span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span> | ((<span class="function">(<span class="params">handle: mixed</span>) =&gt;</span> <span class="keyword">void</span>) &amp; &#123; <span class="attr">_stringRef</span>: ?string &#125;) | <span class="title class_">RefObject</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前处理过程中的组件props对象</span></span><br><span class="line">  <span class="attr">pendingProps</span>: any,</span><br><span class="line">  <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">  <span class="attr">memoizedProps</span>: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">  <span class="attr">updateQueue</span>: <span class="title class_">UpdateQueue</span>&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">  <span class="attr">memoizedState</span>: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line">  <span class="attr">firstContextDependency</span>: <span class="title class_">ContextDependency</span>&lt;mixed&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">mode</span>: <span class="title class_">TypeOfMode</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effect</span></span><br><span class="line">  <span class="comment">// 用来记录Side Effect</span></span><br><span class="line">  <span class="attr">effectTag</span>: <span class="title class_">SideEffectTag</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line">  <span class="attr">nextEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子树中第一个side effect</span></span><br><span class="line">  <span class="attr">firstEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line">  <span class="attr">lastEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes</span></span><br><span class="line">  <span class="attr">expirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line">  <span class="attr">childExpirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的版本池，即记录fiber更新过程，便于恢复</span></span><br><span class="line">  <span class="attr">alternate</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、如何解决"><a href="#三、如何解决" class="headerlink" title="三、如何解决"></a>三、如何解决</h2><p><code>Fiber</code>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行</p>
<p>即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 <code>React Element</code> 对应的 <code>Fiber</code>节点</p>
<p>实现的上述方式的是<code>requestIdleCallback</code>方法</p>
<p><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</p>
<p>首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p>
<p>该实现过程是基于 <code>Fiber</code>节点实现，作为静态的数据结构来说，每个 <code>Fiber</code> 节点对应一个 <code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p>
<p>作为动态的工作单元来说，每个 <code>Fiber</code> 节点保存了本次更新中该组件改变的状态、要执行的工作。</p>
<p>每个 Fiber 节点有个对应的 <code>React element</code>，多个 <code>Fiber</code>节点根据如下三个属性构建一颗树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向父级Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>通过这些属性就能找到下一个执行目标</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/25/React-ant-Design-Pro/">React-ant-Design-Pro总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-ant-pro系统特性"><a href="#1-1-ant-pro系统特性" class="headerlink" title="1.1 ant pro系统特性"></a>1.1 ant pro系统特性</h2><ul>
<li>基于 <code>Ant Design</code> 体系精心设计</li>
<li>使用 <code>React/umi/dva/antd</code> 等前端前沿技术开发</li>
<li>针对不同屏幕大小设计</li>
<li>可配置的主题满足多样化的品牌诉求</li>
<li><code>Mock</code> 数据实用的本地数据调试方案</li>
</ul>
<h2 id="1-2-模板"><a href="#1-2-模板" class="headerlink" title="1.2 模板"></a>1.2 模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- Dashboard</span><br><span class="line">  - 分析页</span><br><span class="line">  - 监控页</span><br><span class="line">  - 工作台</span><br><span class="line">- 表单页</span><br><span class="line">  - 基础表单页</span><br><span class="line">  - 分步表单页</span><br><span class="line">  - 高级表单页</span><br><span class="line">- 列表页</span><br><span class="line">  - 查询表格</span><br><span class="line">  - 标准列表</span><br><span class="line">  - 卡片列表</span><br><span class="line">  - 搜索列表（项目/应用/文章）</span><br><span class="line">- 详情页</span><br><span class="line">  - 基础详情页</span><br><span class="line">  - 高级详情页</span><br><span class="line">- 结果</span><br><span class="line">  - 成功页</span><br><span class="line">  - 失败页</span><br><span class="line">- 异常</span><br><span class="line">  - 403 无权限</span><br><span class="line">  - 404 找不到</span><br><span class="line">  - 500 服务器出错</span><br><span class="line">- 个人页</span><br><span class="line">  - 个人中心</span><br><span class="line">  - 个人设置</span><br><span class="line">- 帐户</span><br><span class="line">  - 登录</span><br><span class="line">  - 注册</span><br><span class="line">  - 注册成功</span><br></pre></td></tr></table></figure>

<h2 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/ant-design/ant-design-pro.git my-project</span><br><span class="line">$ cd my-project</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install ant-design-pro-cli -g</span><br><span class="line">$ mkdir my-project &amp;&amp; cd my-project</span><br><span class="line">$ pro new  # 安装脚手架</span><br></pre></td></tr></table></figure>

<h2 id="1-4-目录结构"><a href="#1-4-目录结构" class="headerlink" title="1.4 目录结构"></a>1.4 目录结构</h2><p>整个项目的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">├── mock                     # 本地模拟数据</span><br><span class="line">├── node_modules             # 依赖库</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico          # Favicon</span><br><span class="line">│   └── index.html           # HTML 入口模板</span><br><span class="line">├── src</span><br><span class="line">│   ├── common               # 应用公用配置，如导航信息</span><br><span class="line">│   ├── components           # 业务通用组件</span><br><span class="line">│   ├── e2e                  # 集成测试用例</span><br><span class="line">│   ├── layouts              # 通用布局</span><br><span class="line">│   ├── models               # dva model</span><br><span class="line">│   ├── routes               # 业务页面入口和常用模板</span><br><span class="line">│   ├── services             # 后台接口服务</span><br><span class="line">│   ├── utils                # 工具库</span><br><span class="line">│   ├── g2.js                # 可视化图形配置</span><br><span class="line">│   ├── polyfill.js          # 兼容性垫片</span><br><span class="line">│   ├── theme.js             # 主题配置</span><br><span class="line">│   ├── index.js             # 应用入口</span><br><span class="line">│   ├── index.less           # 全局样式</span><br><span class="line">│   └── router.js            # 路由入口</span><br><span class="line">├── tests                    # 测试工具</span><br><span class="line">├── .editorconfig            # 编辑器配置</span><br><span class="line">├── .eslintrc                # js代码检测工具</span><br><span class="line">├── .ga                      # 未知</span><br><span class="line">├── .gitignore               # git版本配置</span><br><span class="line">├── .roadhogrc               # roadhog配置</span><br><span class="line">├── .roadhogrc.mock.js       # roadhog的模拟配置</span><br><span class="line">├── .stylelintrc             # css代码审查配置</span><br><span class="line">├── .travis.yml              # travis持续构建工具配置</span><br><span class="line">├── package.json             # web前端项目配置文件</span><br><span class="line">├── README.md</span><br><span class="line">└──</span><br></pre></td></tr></table></figure>

<h2 id="roadhog摘要介绍"><a href="#roadhog摘要介绍" class="headerlink" title="roadhog摘要介绍"></a>roadhog摘要介绍</h2><ul>
<li><code>roadhog</code> 是一个 <code>cli</code> 工具，提供 <code>server</code>、 <code>build</code> 和 test 三个命令，分别用于本地调试和构建，并且提供了特别易用的 mock 功能。命令行体验和 <code>create-react-app</code> 一致，配置略有不同，比如默认开启 <code>css``modules</code>，然后还提供了 <code>JSON</code> 格式的配置方式。</li>
<li>重点介绍<code>roadhog</code>有关的几个配置项，主要是在<code>ant design pro</code>的代码中用到了这些配置项</li>
</ul>
<p><strong>entry</strong></p>
<ul>
<li>指定 <code>webpack</code> 入口文件，支持 <code>glob</code>格式。</li>
<li>如果你的项目是多页类型，会希望把 <code>src/pages</code>的文件作为入口。可以这样配：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;entry&quot;: &quot;src/pages/\*.js&quot;</span><br></pre></td></tr></table></figure>

<p><strong>env</strong></p>
<blockquote>
<p>针对特定的环境进行配置。<code>server</code> 的环境变量是 <code>development</code>，<code>build</code> 的环境变量是<code>production</code>。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;extraBabelPlugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">  &quot;development&quot;: &#123;</span><br><span class="line">    &quot;extraBabelPlugins&quot;: [&quot;dva-hmr&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样，开发环境下的 <code>extraBabelPlugins</code> 是 <code>[&quot;transform-runtime&quot;, &quot;dva-hmr&quot;]</code>，而生产环境下是 <code>[&quot;transform-runtime&quot;]</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">  &quot;development&quot;: &#123;</span><br><span class="line">    &quot;extraBabelPlugins&quot;: [</span><br><span class="line">      &quot;dva-hmr&quot;,</span><br><span class="line">      &quot;transform-runtime&quot;,</span><br><span class="line">      &quot;transform-decorators-legacy&quot;,</span><br><span class="line">      &quot;transform-class-properties&quot;,</span><br><span class="line">      [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true &#125;]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;production&quot;: &#123;</span><br><span class="line">    &quot;extraBabelPlugins&quot;: [</span><br><span class="line">      &quot;transform-runtime&quot;,</span><br><span class="line">      &quot;transform-decorators-legacy&quot;,</span><br><span class="line">      &quot;transform-class-properties&quot;,</span><br><span class="line">      [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: true &#125;]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这段代码中，开发环境和生产环境分别配置，其中开发环境使用了<code>dva-hmr</code>插件</p>
</blockquote>
<h1 id="二、布局"><a href="#二、布局" class="headerlink" title="二、布局"></a>二、布局</h1><blockquote>
<p>页面整体布局是一个产品最外层的框架结构，往往会包含导航、页脚、侧边栏、通知栏以及内容等。在页面之中，也有很多区块的布局结构。在真实项目中，页面布局通常统领整个应用的界面，有非常重要的作用</p>
</blockquote>
<h2 id="2-1-Ant-Design-Pro-的布局"><a href="#2-1-Ant-Design-Pro-的布局" class="headerlink" title="2.1 Ant Design Pro 的布局"></a>2.1 Ant Design Pro 的布局</h2><blockquote>
<p>在 Ant Design Pro 中，我们抽离了使用过程中的通用布局，都放在 <code>layouts</code> 目录中，分别为</p>
</blockquote>
<p><strong>BasicLayout：基础页面布局，包含了头部导航，侧边栏和通知栏</strong></p>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/oXmyfmffJVvdbmDoGvuF.png" alt="img"></p>
<p><strong>UserLayout：抽离出用于登陆注册页面的通用布局</strong></p>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/mXsydBXvLqBVEZLMssEy.png" alt="img"></p>
<p><strong>BlankLayout：空白的布局</strong></p>
<h2 id="2-2-如何使用-Ant-Design-Pro-布局"><a href="#2-2-如何使用-Ant-Design-Pro-布局" class="headerlink" title="2.2 如何使用 Ant Design Pro 布局"></a>2.2 如何使用 Ant Design Pro 布局</h2><blockquote>
<p>通常布局是和路由系统紧密结合的，Ant Design Pro 的路由使用了 <code>Umi</code> 的路由方案，为了统一方便的管理路由和页面的关系，我们将配置信息统一抽离到 <code>config/router.config.js</code> 下，通过如下配置定义每个页面的布局</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = [&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  component: &#x27;../layouts/BasicLayout&#x27;,  // 指定以下页面的布局</span><br><span class="line">  routes: [</span><br><span class="line">    // dashboard</span><br><span class="line">    &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27; &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/dashboard&#x27;,</span><br><span class="line">      name: &#x27;dashboard&#x27;,</span><br><span class="line">      icon: &#x27;dashboard&#x27;,</span><br><span class="line">      routes: [</span><br><span class="line">        &#123; path: &#x27;/dashboard/analysis&#x27;, name: &#x27;analysis&#x27;, component: &#x27;./Dashboard/Analysis&#x27; &#125;,</span><br><span class="line">        &#123; path: &#x27;/dashboard/monitor&#x27;, name: &#x27;monitor&#x27;, component: &#x27;./Dashboard/Monitor&#x27; &#125;,</span><br><span class="line">        &#123; path: &#x27;/dashboard/workplace&#x27;, name: &#x27;workplace&#x27;, component: &#x27;./Dashboard/Workplace&#x27; &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多 Umi 的路由配置方式可以参考：<a target="_blank" rel="noopener" href="https://umijs.org/guide/router.html#%E9%85%8D%E7%BD%AE%E5%BC%8F%E8%B7%AF%E7%94%B1">Umi 配置式路由</a></p>
</blockquote>
<h2 id="2-3-Pro-扩展配置"><a href="#2-3-Pro-扩展配置" class="headerlink" title="2.3 Pro 扩展配置"></a>2.3 Pro 扩展配置</h2><blockquote>
<p>我们在 <code>router.config.js</code> 扩展了一些关于 <code>pro</code> 全局菜单的配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &#x27;dashboard&#x27;,</span><br><span class="line">  icon: &#x27;dashboard&#x27;,</span><br><span class="line">  hideInMenu: true,</span><br><span class="line">  hideChildrenInMenu: true,</span><br><span class="line">  hideInBreadcrumb: true,</span><br><span class="line">  authority: [&#x27;admin&#x27;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code>: 当前路由在菜单和面包屑中的名称，注意这里是国际化配置的 <code>key</code>，具体展示菜单名可以在 <code>/src/locales/zh-CN.js</code> 进行配置。</li>
<li><code>icon</code>: 当前路由在菜单下的图标名。</li>
<li><code>hideInMenu</code>: 当前路由在菜单中不展现，默认 <code>false</code>。</li>
<li><code>hideChildrenInMenu</code>: 当前路由的子级在菜单中不展现，默认 <code>false</code>。</li>
<li><code>hideInBreadcrumb</code>: 当前路由在面包屑中不展现，默认 <code>false</code>。</li>
<li><code>authority</code>: 允许展示的权限，不设则都可见，详见：权限管理</li>
</ul>
<h2 id="2-4-Ant-Design-布局组件"><a href="#2-4-Ant-Design-布局组件" class="headerlink" title="2.4 Ant Design 布局组件"></a>2.4 Ant Design 布局组件</h2><blockquote>
<p>除了 Pro 里的内建布局以为，在一些页面中需要进行布局，可以使用 Ant Design 目前提供的两套布局组件工具：<code>Layout</code> 和 <code>Grid</code></p>
</blockquote>
<p><strong>Grid 组件</strong></p>
<blockquote>
<ul>
<li>栅格布局是网页中最常用的布局，其特点就是按照一定比例划分页面，能够随着屏幕的变化依旧保持比例，从而具有弹性布局的特点。</li>
<li>而 Ant Design 的栅格组件提供的功能更为强大，能够设置间距、具有支持响应式的比例设置，以及支持 flex 模式，基本上涵盖了大部分的布局场景 <a target="_blank" rel="noopener" href="https://ant.design/components/grid/">https://ant.design/components/grid/</a></li>
</ul>
</blockquote>
<p><strong>Layout 组件</strong></p>
<blockquote>
<p>如果你需要辅助页面框架级别的布局设计，那么 Layout 则是你最佳的选择，它抽象了大部分框架布局结构，使得只需要填空就可以开发规范专业的页面整体布局 <a target="_blank" rel="noopener" href="https://ant.design/components/layout-cn/">https://ant.design/components/layout-cn/</a></p>
</blockquote>
<ul>
<li>根据不同场景区分抽离布局组件#<br>在大部分场景下，我们需要基于上面两个组件封装一些适用于当下具体业务的组件，包含了通用的导航、侧边栏、顶部通知、页面标题等元素。例如 Ant Design Pro 的 <code>BasicLayout</code>。</li>
<li>通常，我们会把抽象出来的布局组件，放到跟 pages、 components 平行的 layouts 文件夹中方便管理。需要注意的是，这些布局组件和我们平时使用的其它组件并没有什么不同，只不过功能性上是为了处理布局问题</li>
</ul>
<h1 id="四、路由和菜单"><a href="#四、路由和菜单" class="headerlink" title="四、路由和菜单"></a>四、路由和菜单</h1><blockquote>
<p>路由和菜单是组织起一个应用的关键骨架，pro 中的路由为了方便管理，使用了中心化的方式，在 <code>router.config.js</code> 统一配置和管理</p>
</blockquote>
<h2 id="4-1-基本结构"><a href="#4-1-基本结构" class="headerlink" title="4.1 基本结构"></a>4.1 基本结构</h2><ul>
<li><strong>路由管理</strong> 通过约定的语法根据在 <code>router.config.js</code> 中配置路由。</li>
<li><strong>菜单生成</strong> 根据路由配置来生成菜单。菜单项名称，嵌套路径与路由高度耦合。</li>
<li><strong>面包屑</strong> 组件 <a target="_blank" rel="noopener" href="https://pro.ant.design/components/PageHeader-cn">PageHeader</a> 中内置的面包屑也可由脚手架提供的配置信息自动生成</li>
</ul>
<h3 id="4-1-1-路由"><a href="#4-1-1-路由" class="headerlink" title="4.1.1 路由"></a>4.1.1 路由</h3><blockquote>
<p>目前脚手架中所有的路由都通过 <code>router.config.js</code> 来统一管理，在 <code>umi</code> 的配置中我们增加了一些参数，如<code>name</code>,<code>icon</code>,<code>hideChildren</code>,<code>authority</code>，来辅助生成菜单。其中</p>
</blockquote>
<ul>
<li><code>name</code> 和 <code>icon</code>分别代表生成菜单项的图标和文本。</li>
<li><code>hideChildren</code> 用于隐藏不需要在菜单中展示的子路由。用法可以查看 分步表单 的配置。</li>
<li><code>hideInMenu</code> 可以在菜单中不展示这个路由，包括子路由。效果可以查看 <code>exception/trigger</code>页面。</li>
<li><code>authority</code> 用来配置这个路由的权限，如果配置了将会验证当前用户的权限，并决定是否展示</li>
</ul>
<h3 id="4-1-2-菜单"><a href="#4-1-2-菜单" class="headerlink" title="4.1.2 菜单"></a>4.1.2 菜单</h3><blockquote>
<p>菜单根据 <code>router.config.js</code> 生成，具体逻辑在 <code>src/layouts/BasicLayout</code> 中的 <code>formatter</code> 方法实现</p>
</blockquote>
<ul>
<li>如果你的项目并不需要菜单，你可以直接在<code>BasicLayout</code> 中删除 <code>SiderMenu</code> 组件的挂载。并在 <code>src/layouts/BasicLayout</code> 中 设置 <code>const MenuData = []</code>。</li>
<li>如果你需要从服务器请求菜单，可以将<code>menuData</code>设置为 <code>state</code>，然后通过网络获取来修改了 <code>state</code></li>
</ul>
<h3 id="4-1-3-面包屑"><a href="#4-1-3-面包屑" class="headerlink" title="4.1.3 面包屑"></a>4.1.3 面包屑</h3><blockquote>
<p>面包屑由 <code>PageHeaderLayout</code> 实现，<code>MenuContext</code> 将 根据 <code>MenuData</code> 生成的 <code>breadcrumbNameMap</code> 通过<code>props</code> 传递给了 <code>PageHeader</code>，如果你要做自定义的面包屑，可以通过修改传入的 <code>breadcrumbNameMap</code> 来解决</p>
</blockquote>
<p><code>breadcrumbNameMap</code> 示例数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;/&#x27;: &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27;, locale: &#x27;menu&#x27; &#125;,</span><br><span class="line">  &#x27;/dashboard/analysis&#x27;: &#123;</span><br><span class="line">    name: &#x27;analysis&#x27;,</span><br><span class="line">    component: &#x27;./Dashboard/Analysis&#x27;,</span><br><span class="line">    locale: &#x27;menu.dashboard.analysis&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-需求实例"><a href="#4-2-需求实例" class="headerlink" title="4.2 需求实例"></a>4.2 需求实例</h2><h3 id="4-2-1-新增页面"><a href="#4-2-1-新增页面" class="headerlink" title="4.2.1 新增页面"></a>4.2.1 新增页面</h3><blockquote>
<p>脚手架默认提供了两种布局模板：基础布局 - <code>BasicLayout</code> 以及 账户相关布局 - <code>UserLayout</code></p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/oXmyfmffJVvdbmDoGvuF.png" alt="img"></p>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/mXsydBXvLqBVEZLMssEy.png" alt="img"></p>
<p>如果你的页面可以利用这两种布局，那么只需要在路由配置中增加一条即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // app</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    component: &#x27;../layouts/BasicLayout&#x27;,</span><br><span class="line">    routes: [</span><br><span class="line">      // dashboard</span><br><span class="line">      &#123; path: &#x27;/&#x27;, redirect: &#x27;/dashboard/analysis&#x27; &#125;,</span><br><span class="line">      &#123; path :&#x27;/dashboard/test&#x27;,component:&quot;./Dashboard/Test&quot;&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加好后，会默认生成相关的路由及导航</p>
</blockquote>
<h3 id="4-2-2-新增布局"><a href="#4-2-2-新增布局" class="headerlink" title="4.2.2 新增布局"></a>4.2.2 新增布局</h3><blockquote>
<p>在脚手架中我们通过嵌套路由来实现布局模板。<code>router.config.js</code> 是一个数组，其中第一级数据就是我们的布局，如果你需要新增布局可以在直接增加一个新的一级数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module.exports = [</span><br><span class="line">   // user</span><br><span class="line">   &#123;</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: &#x27;../layouts/UserLayout&#x27;,</span><br><span class="line">    routes:[...]</span><br><span class="line">   &#125;,</span><br><span class="line">   // app</span><br><span class="line">   &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    component: &#x27;../layouts/BasicLayout&#x27;,</span><br><span class="line">    routes:[...]</span><br><span class="line">   &#125;,</span><br><span class="line">   // new</span><br><span class="line">   &#123;</span><br><span class="line">    path: &#x27;/new&#x27;,</span><br><span class="line">    component: &#x27;../layouts/new_page&#x27;,</span><br><span class="line">    routes:[...]</span><br><span class="line">   &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-带参数的路由"><a href="#4-2-3-带参数的路由" class="headerlink" title="4.2.3 带参数的路由"></a>4.2.3 带参数的路由</h3><blockquote>
<p>脚手架默认支持带参数的路由,但是在菜单中显示带参数的路由并不是个好主意，我们并不会自动的帮你注入一个参数，你可能需要在代码中自行处理</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    path: &#x27;/dashboard/:page&#x27;,</span><br><span class="line">    hideInMenu:true, </span><br><span class="line">    name: &#x27;analysis&#x27;, </span><br><span class="line">    component: &#x27;./Dashboard/Analysis&#x27; </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>你可以通过以下代码来跳转到这个路由</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import router from &#x27;umi/router&#x27;;</span><br><span class="line"></span><br><span class="line">router.push(&#x27;/dashboard/anyParams&#x27;)</span><br><span class="line"></span><br><span class="line">//or</span><br><span class="line"></span><br><span class="line">import Link from &#x27;umi/link&#x27;;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&quot;/dashboard/anyParams&quot;&gt;go&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在路由组件中，可以通过<code>this.props.match.params</code> 来获得路由参数</p>
</blockquote>
<h1 id="五、新增页面"><a href="#五、新增页面" class="headerlink" title="五、新增页面"></a>五、新增页面</h1><blockquote>
<p>这里的『页面』指配置了路由，能够通过链接直接访问的模块，要新建一个页面，通常只需要在脚手架的基础上进行简单的配置</p>
</blockquote>
<h2 id="5-1-新增-js、less"><a href="#5-1-新增-js、less" class="headerlink" title="5.1 新增 js、less"></a>5.1 新增 js、less</h2><blockquote>
<p>在 <code>src/pages</code> 下新建页面的 <code>js</code> 及 <code>less</code> 文件，如果相关页面有多个，可以新建一个文件夹来放置相关文件</p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/hjDyFTVOgRwDzAIHApMO.png" alt="img"></p>
<blockquote>
<p>样式文件默认使用 CSS Modules，如果需要，你可以在样式文件的头部引入 antd 样式变量文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;~antd/lib/style/themes/default.less&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-将文件加入菜单和路由"><a href="#5-2-将文件加入菜单和路由" class="headerlink" title="5.2 将文件加入菜单和路由"></a>5.2 将文件加入菜单和路由</h2><blockquote>
<p>加入菜单和路由的方式请参照 路由和菜单 - 添加路由/菜单 中的介绍完成。加好后，访问 <code>http://localhost:8000/#/new</code> 就可以看到新增的页面了 <a target="_blank" rel="noopener" href="https://pro.ant.design/docs/router-and-nav-cn#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/%E8%8F%9C%E5%8D%95">https://pro.ant.design/docs/router-and-nav-cn#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1/%E8%8F%9C%E5%8D%95</a></p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/xZIqExWKhdnzDBjajnZg.png" alt="img"></p>
<h2 id="5-3-新增-model、service"><a href="#5-3-新增-model、service" class="headerlink" title="5.3 新增 model、service"></a>5.3 新增 model、service</h2><blockquote>
<p>布局及路由都配置好之后，回到之前新建的 <code>NewPage.js</code>，可以开始写业务代码了！如果需要用到 <code>dva</code>中的数据流，还需要在 <code>src/models src/services</code> 中建立相应的<code>model</code> 和 service，具体可以参考脚手架内置页面的写法</p>
</blockquote>
<h1 id="六、新增业务组件"><a href="#六、新增业务组件" class="headerlink" title="六、新增业务组件"></a>六、新增业务组件</h1><blockquote>
<p>对于一些可能被多处引用的功能模块，建议提炼成业务组件统一管理。这些组件一般有以下特征：</p>
</blockquote>
<ul>
<li>只负责一块相对独立，稳定的功能；</li>
<li>没有单独的路由配置；</li>
<li>可能是纯静态的，也可能包含自己的 state，但不涉及 dva 的数据流，仅受父组件（通常是一个页面）传递的参数控制。</li>
</ul>
<p><strong>新建文件</strong></p>
<blockquote>
<p>在 <code>src/components</code> 下新建一个以组件名命名的文件夹，注意首字母大写，命名尽量体现组件的功能，这里就叫 <code>ImageWrapper</code>。在此文件夹下新增 js 文件及样式文件（如果需要），命名为 <code>index.js</code>和 <code>index.less</code></p>
</blockquote>
<ul>
<li>在使用组件时，默认会在 <code>index.js</code> 中寻找 <code>export</code> 的对象，如果你的组件比较复杂，可以分为多个文件，最后在 <code>index.js</code>中统一 <code>export</code>，就像这样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// MainComponent.js</span><br><span class="line">export default (&#123; ... &#125;) =&gt; (...);</span><br><span class="line"></span><br><span class="line">// SubComponent1.js</span><br><span class="line">export default (&#123; ... &#125;) =&gt; (...);</span><br><span class="line"></span><br><span class="line">// SubComponent2.js</span><br><span class="line">export default (&#123; ... &#125;) =&gt; (...);</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">import MainComponent from &#x27;./MainComponent&#x27;;</span><br><span class="line">import SubComponent1 from &#x27;./SubComponent1&#x27;;</span><br><span class="line">import SubComponent2 from &#x27;./SubComponent2&#x27;;</span><br><span class="line"></span><br><span class="line">MainComponent.SubComponent1 = SubComponent1;</span><br><span class="line">MainComponent.SubComponent2 = SubComponent2;</span><br><span class="line">export default MainComponent;</span><br></pre></td></tr></table></figure>

<p>你的代码大概是这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import styles from &#x27;./index.less&#x27;;    // 按照 CSS Modules 的方式引入样式文件。</span><br><span class="line"></span><br><span class="line">export default (&#123; src, desc, style &#125;) =&gt; (</span><br><span class="line">  &lt;div style=&#123;style&#125; className=&#123;styles.imageWrapper&#125;&gt;</span><br><span class="line">    &lt;img className=&#123;styles.img&#125; src=&#123;src&#125; alt=&#123;desc&#125; /&gt;</span><br><span class="line">    &#123;desc &amp;&amp; &lt;div className=&#123;styles.desc&#125;&gt;&#123;desc&#125;&lt;/div&gt;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">// index.less</span><br><span class="line">.imageWrapper &#123;</span><br><span class="line">  padding: 0 20px 8px;</span><br><span class="line">  background: #f2f4f5;</span><br><span class="line">  width: 400px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.img &#123;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  max-width: calc(100% - 32px);</span><br><span class="line">  margin: 2.4em 1em;</span><br><span class="line">  box-shadow: 0 8px 20px rgba(143, 168, 191, 0.35);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<blockquote>
<p>在要使用这个组件的地方，按照组件定义的 <code>API</code> 传入参数，直接使用就好，不过别忘了先引入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ImageWrapper from &#x27;@/components/ImageWrapper&#x27;;  // @ 表示相对于源文件根目录</span><br><span class="line"></span><br><span class="line">export default () =&gt; (</span><br><span class="line">  &lt;ImageWrapper</span><br><span class="line">    src=&quot;https://os.alipayobjects.com/rmsportal/mgesTPFxodmIwpi.png&quot;</span><br><span class="line">    desc=&quot;示意图&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="七、样式"><a href="#七、样式" class="headerlink" title="七、样式"></a>七、样式</h1><p><strong>less</strong></p>
<blockquote>
<p>Ant Design Pro 默认使用 less 作为样式语言</p>
</blockquote>
<p><strong>CSS Modules</strong></p>
<p>在样式开发过程中，有两个问题比较突出</p>
<ul>
<li>全局污染 —— CSS 文件中的选择器是全局生效的，不同文件中的同名选择器，根据 build 后生成文件中的先后顺序，后面的样式会将前面的覆盖；</li>
<li>选择器复杂 —— 为了避免上面的问题，我们在编写样式的时候不得不小心翼翼，类名里会带上限制范围的标识，变得越来越长，多人开发时还很容易导致命名风格混乱，一个元素上使用的选择器个数也可能越来越多。</li>
</ul>
<blockquote>
<p>为了解决上述问题，我们的脚手架默认使用 CSS Modules 模块化方案，先来看下在这种模式下怎么写样式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">import styles from &#x27;./example.less&#x27;;</span><br><span class="line"></span><br><span class="line">export default (&#123; title &#125;) =&gt; &lt;div className=&#123;styles.title&#125;&gt;&#123;title&#125;&lt;/div&gt;;</span><br><span class="line">// example.less</span><br><span class="line">.title &#123;</span><br><span class="line">  color: @heading-color;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 less 写样式好像没什么改变，只是类名比较简单（实际项目中也是这样），js 文件的改变就是在设置 <code>className</code> 时，用一个对象属性取代了原来的字符串，属性名跟 less 文件中对应的类名相同，对象从 less 文件中引入。</li>
<li>在上面的样式文件中，<code>.title</code> 只会在本文件生效，你可以在其他任意文件中使用同名选择器，也不会对这里造成影响。不过有的时候，我们就是想要一个全局生效的样式呢？可以使用 <code>:global</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// example.less</span><br><span class="line">.title &#123;</span><br><span class="line">  color: @heading-color;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义全局样式 */</span><br><span class="line">:global(.text) &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 定义多个全局样式 */</span><br><span class="line">:global &#123;</span><br><span class="line">  .footer &#123;</span><br><span class="line">    color: #ccc;</span><br><span class="line">  &#125;</span><br><span class="line">  .sider &#123;</span><br><span class="line">    background: #ebebeb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CSS Modules 的基本原理很简单，就是对每个类名（非 <code>:global</code> 声明的）按照一定规则进行转换，保证它的唯一性。如果在浏览器里查看这个示例的 dom 结构，你会发现实际渲染出来是这样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;title___3TqAx&quot;&gt;title&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>类名被自动添加了一个 <code>hash</code> 值，这保证了它的唯一性</li>
</ul>
<p><strong>样式文件类别</strong></p>
<blockquote>
<p>在一个项目中，样式文件根据功能不同，可以划分为不同的类别</p>
</blockquote>
<ul>
<li><code>src/index.less#</code></li>
</ul>
<blockquote>
<p>全局样式文件，在这里你可以进行一些通用设置，比如脚手架中自带的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">html, body, :global(#root) &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  text-rendering: optimizeLegibility;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// temporary font size patch</span><br><span class="line">:global(.ant-tag) &#123;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>src/utils/utils.less#</code></li>
</ul>
<blockquote>
<p>这里可以放置一些工具函数供调用，比如清除浮动 <code>.clearfix</code></p>
</blockquote>
<ul>
<li>模块样式</li>
</ul>
<blockquote>
<p>针对某个模块/页面生效的文件</p>
</blockquote>
<h1 id="八、和服务端进行交互"><a href="#八、和服务端进行交互" class="headerlink" title="八、和服务端进行交互"></a>八、和服务端进行交互</h1><p><strong>前端请求流程</strong></p>
<blockquote>
<p>在 Ant Design Pro 中，一个完整的前端 UI 交互到服务端处理流程是这样的</p>
</blockquote>
<ul>
<li>UI 组件交互操作；</li>
<li>调用 <code>model</code> 的 <code>effect</code>；</li>
<li>调用统一管理的 <code>service</code> 请求函数；</li>
<li>使用封装的 <code>request.js</code>发送请求；</li>
<li>获取服务端返回；</li>
<li>然后调用<code>reducer</code>改变 <code>state</code>；</li>
<li>更新 <code>model</code></li>
</ul>
<blockquote>
<p>为了方便管理维护，统一的请求处理都放在 services 文件夹中，并且一般按照 model 维度进行拆分文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services/</span><br><span class="line">  user.js</span><br><span class="line">  api.js</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，<code>utils/request.js</code>是基于 <code>fetch</code> 的封装，便于统一处理 POST，GET 等请求参数，请求头，以及错误提示信息等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// services/user.js</span><br><span class="line">import request from &#x27;../utils/request&#x27;;</span><br><span class="line"></span><br><span class="line">export async function query() &#123;</span><br><span class="line">  return request(&#x27;/api/users&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function queryCurrent() &#123;</span><br><span class="line">  return request(&#x27;/api/currentUser&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// models/user.js</span><br><span class="line">import &#123; queryCurrent &#125; from &#x27;../services/user&#x27;;</span><br><span class="line">...</span><br><span class="line">effects: &#123;</span><br><span class="line">  *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    const response = yield call(queryUsers);</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理异步请求</strong></p>
<blockquote>
<p>在处理复杂的异步请求的时候，很容易让逻辑混乱，陷入嵌套陷阱，所以 <code>Ant Design Pro</code> 的底层基础框架 <code>dva</code>使用 <code>effect</code> 的方式来管理同步化异步请求</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">effects: &#123;</span><br><span class="line">  *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: &#x27;changeLoading&#x27;,</span><br><span class="line">      payload: true,</span><br><span class="line">    &#125;);</span><br><span class="line">    // 异步请求 1</span><br><span class="line">    const response = yield call(queryFakeList, payload);</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: &#x27;save&#x27;,</span><br><span class="line">      payload: response,</span><br><span class="line">    &#125;);</span><br><span class="line">    // 异步请求 2</span><br><span class="line">    const response2 = yield call(queryFakeList2, payload);</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: &#x27;save2&#x27;,</span><br><span class="line">      payload: response2,</span><br><span class="line">    &#125;);</span><br><span class="line">    yield put(&#123;</span><br><span class="line">      type: &#x27;changeLoading&#x27;,</span><br><span class="line">      payload: false,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="九、引入外部模块"><a href="#九、引入外部模块" class="headerlink" title="九、引入外部模块"></a>九、引入外部模块</h1><blockquote>
<p>除了<code>antd</code>组件以及脚手架内置的业务组件，有时我们还需要引入其他外部模块，这里以引入富文本组件 <code>react-quill</code> 为例进行介绍</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ npm install react-quill --save</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button, notification, Card &#125; from &#x27;antd&#x27;;</span><br><span class="line">import ReactQuill from &#x27;react-quill&#x27;; </span><br><span class="line">import &#x27;react-quill/dist/quill.snow.css&#x27;;</span><br><span class="line"></span><br><span class="line">export default class NewPage extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    value: &#x27;test&#x27;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleChange = (value) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  prompt = () =&gt; &#123;</span><br><span class="line">    notification.open(&#123;</span><br><span class="line">      message: &#x27;We got value:&#x27;,</span><br><span class="line">      description: &lt;span dangerouslySetInnerHTML=&#123;&#123; __html: this.state.value &#125;&#125;&gt;&lt;/span&gt;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Card title=&quot;富文本编辑器&quot;&gt;</span><br><span class="line">        &lt;ReactQuill value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;Button style=&#123;&#123; marginTop: 16 &#125;&#125; onClick=&#123;this.prompt&#125;&gt;Prompt&lt;/Button&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十、图表"><a href="#十、图表" class="headerlink" title="十、图表"></a>十、图表</h1><blockquote>
<p>Ant Design Pro 提供了由设计师精心设计抽象的图表类型，是在 <code>BizCharts</code> 图表库基础上的二次封装，同时提供了业务中常用的图表套件，可以单独使用，也可以组合起来实现复杂的展示效果</p>
</blockquote>
<blockquote>
<p>图表组件 <a target="_blank" rel="noopener" href="https://pro.ant.design/components/Charts-cn/">https://pro.ant.design/components/Charts-cn/</a></p>
</blockquote>
<p><strong>使用 Ant Design Pro 的图表</strong></p>
<p>Charts 图表套件是在 <code>components/Charts</code> 包中，引用到项目就像使用其它组件一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ChartCard, MiniBar &#125; from &#x27;@/components/Charts&#x27;;</span><br><span class="line">import &#123; Tooltip, Icon &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">const visitData = [</span><br><span class="line">  &#123;</span><br><span class="line">    x: &quot;2017-09-01&quot;,</span><br><span class="line">    y: 100</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    x: &quot;2017-09-02&quot;,</span><br><span class="line">    y: 120</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    x: &quot;2017-09-03&quot;,</span><br><span class="line">    y: 88</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    x: &quot;2017-09-04&quot;,</span><br><span class="line">    y: 65</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ChartCard</span><br><span class="line">    title=&quot;支付笔数&quot;</span><br><span class="line">    action=&#123;</span><br><span class="line">      &lt;Tooltip title=&quot;支付笔数反应交易质量&quot;&gt;</span><br><span class="line">        &lt;Icon type=&quot;exclamation-circle-o&quot; /&gt;</span><br><span class="line">      &lt;/Tooltip&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    total=&quot;6,500&quot;</span><br><span class="line">    contentHeight=&#123;46&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;MiniBar height=&#123;46&#125; data=&#123;visitData&#125; /&gt;</span><br><span class="line">  &lt;/ChartCard&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/BizCharts">https://github.com/alibaba/BizCharts</a></p>
<p><strong>使用 BizCharts 绘制图表</strong></p>
<blockquote>
<p>如果 <code>Ant Design Pro</code> 不能满足你的业务需求，可以直接使用 <code>BizCharts</code> 封装自己的图表组件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install bizcharts --save</span><br><span class="line">import &#123; Chart, Axis, Tooltip, Geom &#125; from &#x27;bizcharts&#x27;;</span><br><span class="line"></span><br><span class="line">const data = [...];</span><br><span class="line"></span><br><span class="line">&lt;Chart height=&#123;400&#125; data=&#123;data&#125; forceFit&gt;</span><br><span class="line">  &lt;Axis name=&quot;month&quot; /&gt;</span><br><span class="line">  &lt;Axis name=&quot;temperature&quot; label=&#123;&#123; formatter: val =&gt; `$&#123;val&#125;°C` &#125;&#125; /&gt;</span><br><span class="line">  &lt;Tooltip crosshairs=&#123;&#123; type : &quot;y&quot; &#125;&#125; /&gt;</span><br><span class="line">  &lt;Geom type=&quot;line&quot; position=&quot;month*temperature&quot; size=&#123;2&#125; color=&#123;&#x27;city&#x27;&#125; /&gt;</span><br><span class="line">  &lt;Geom type=&#x27;point&#x27; position=&quot;month*temperature&quot; size=&#123;4&#125; color=&#123;&#x27;city&#x27;&#125; /&gt;</span><br><span class="line">&lt;/Chart&gt;</span><br></pre></td></tr></table></figure>

<h1 id="十一、业务图标"><a href="#十一、业务图标" class="headerlink" title="十一、业务图标"></a>十一、业务图标</h1><blockquote>
<p>通常情况下，你可以通过 <code>Ant Design</code> 提供的 `` 图标组件来使用 Ant Design 官方图标。基本使用方式如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Icon type=&quot;heart&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;hotpink&#x27; &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你没有在 <code>Ant Design</code> 官方图标中找到需要的图标，可以到 <code>iconfont.cn</code> 上采集并生成自己的业务图标库，再进行使用</p>
</blockquote>
<p><strong>生成图标库代码</strong></p>
<ul>
<li>首先，搜索并找到你需要的图标，将它采集到你的购物车里，在购物车里，你可以将选中的图标添加到项目中（没有的话，新建一个），后续生成的资源/代码都是以项目为维度的。</li>
<li>如果你已经有了设计稿，只是需要生成相关代码，可以上传你的图标后，再进行上面的操作</li>
</ul>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/jJQYzRyqVFBBamUOppXH.png" alt="img"></p>
<blockquote>
<p>来到刚才选中的项目页，点击『生成代码』的链接，会在下方生成不同引入方式的代码，下面会分别介绍</p>
</blockquote>
<p><img src="https://gw.alipayobjects.com/zos/rmsportal/DbDSgiRukSANKWyhULir.png" alt="img"></p>
<p><strong>引入</strong></p>
<ul>
<li>有三种引入方式供你选择：<code>SVG Symbol</code>、<code>Unicode</code> 及 <code>Font class</code>。我们推荐在现代浏览器下使用 <code>SVG Symbol</code>方式引入。</li>
</ul>
<blockquote>
<p>SVG 符号引入是现代浏览器未来主流的图标引入方式。其方法是预先加载符号，在合适的地方引入并渲染为矢量图形。有如下特点：</p>
</blockquote>
<ul>
<li>支持多色图标，不再受到单色图标的限制</li>
<li>通过一些技巧，支持像字体那样，通过 <code>font-size</code>、<code>color</code> 来调整样式</li>
<li>支持IE 9+ 及现代浏览器</li>
</ul>
<blockquote>
<p>切换到 <code>Symbol</code> 页签，复制项目生成的地址代码：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js</span><br></pre></td></tr></table></figure>

<p>加入图标样式代码，如果没有特殊的要求，你可以直接复用 Ant Design 图标的样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.icon &#123;</span><br><span class="line">  width: 1em;</span><br><span class="line">  height: 1em;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">  vertical-align: -.125em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑选相应图标并获取类名，应用于页面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use xlink:href=&quot;#icon-ali-pay&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p>你也可以通过使用 Ant Design 图标组件提供的 <code>Icon.createFromIconfontCN(&#123;...&#125;)</code> 方法来更加方便地使用图标，使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Icon &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">const IconFont = Icon.createFromIconfontCN(&#123;</span><br><span class="line">  scriptUrl: &#x27;//at.alicdn.com/t/font_405362_lyhvoky9rc7ynwmi.js&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default IconFont;</span><br></pre></td></tr></table></figure>

<p>之后可以像使用 `` 组件一样方便地使用，支持配置样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IconFont type=&quot;icon-ali-pay&quot; style=&#123;&#123; fontSize: &#x27;16px&#x27;, color: &#x27;lightblue&#x27; &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解更多用法 <a target="_blank" rel="noopener" href="https://pro.ant.design/docs/biz-icon-cn#%E4%BA%8C%E3%80%81%E5%BC%95%E5%85%A5">https://pro.ant.design/docs/biz-icon-cn#%E4%BA%8C%E3%80%81%E5%BC%95%E5%85%A5</a></p>
</blockquote>
<h1 id="十二、Mock-和联调"><a href="#十二、Mock-和联调" class="headerlink" title="十二、Mock 和联调"></a>十二、Mock 和联调</h1><blockquote>
<p>Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发独立自主，不会被服务端的开发所阻塞</p>
</blockquote>
<ul>
<li>在 <code>Ant Design Pro</code> 中，因为我们的底层框架是 <code>umi</code>，而它自带了代理请求功能，通过代理请求就能够轻松处理数据模拟的功能</li>
</ul>
<p><strong>使用 umi 的 mock 功能</strong></p>
<blockquote>
<p>umi 里约定 mock 文件夹下的文件即 mock 文件，文件导出接口定义，支持基于 require 动态分析的实时刷新，支持 ES6 语法，以及友好的出错提示</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  // 支持值为 Object 和 Array</span><br><span class="line">  &#x27;GET /api/users&#x27;: &#123; users: [1, 2] &#125;,</span><br><span class="line"></span><br><span class="line">  // GET POST 可省略</span><br><span class="line">  &#x27;/api/users/1&#x27;: &#123; id: 1 &#125;,</span><br><span class="line"></span><br><span class="line">  // 支持自定义函数，API 参考 express@4</span><br><span class="line">  &#x27;POST /api/users/create&#x27;: (req, res) =&gt; &#123; res.end(&#x27;OK&#x27;); &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当客户端（浏览器）发送请求，如：<code>GET /api/users</code>，那么本地启动的 umi dev 会跟此配置文件匹配请求路径以及方法，如果匹配到了，就会将请求通过配置处理，就可以像样例一样，你可以直接返回数据，也可以通过函数处理以及重定向到另一个服务器</p>
</blockquote>
<p>了解更多 <a target="_blank" rel="noopener" href="https://pro.ant.design/docs/mock-api-cn#%E4%BD%BF%E7%94%A8-umi-%E7%9A%84-mock-%E5%8A%9F%E8%83%BD">https://pro.ant.design/docs/mock-api-cn#%E4%BD%BF%E7%94%A8-umi-%E7%9A%84-mock-%E5%8A%9F%E8%83%BD</a></p>
<h1 id="十三、主题定制"><a href="#十三、主题定制" class="headerlink" title="十三、主题定制"></a>十三、主题定制</h1><blockquote>
<p>我们基于 Ant Design React 进行开发，完全支持官方提供的 less 变量定制功能. 你可以在脚手架目录中找到 <code>config/config.js</code> 代码类似这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">theme: &#123;</span><br><span class="line">  &#x27;font-size-base&#x27;: &#x27;14px&#x27;,</span><br><span class="line">  &#x27;badge-font-size&#x27;: &#x27;12px&#x27;,</span><br><span class="line">  &#x27;btn-font-size-lg&#x27;: &#x27;@font-size-base&#x27;,</span><br><span class="line">  &#x27;menu-dark-bg&#x27;: &#x27;#00182E&#x27;,</span><br><span class="line">  &#x27;menu-dark-submenu-bg&#x27;: &#x27;#000B14&#x27;,</span><br><span class="line">  &#x27;layout-sider-background&#x27;: &#x27;#00182E&#x27;,</span><br><span class="line">  &#x27;layout-body-background&#x27;: &#x27;#f0f2f5&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="十四、权限管理"><a href="#十四、权限管理" class="headerlink" title="十四、权限管理"></a>十四、权限管理</h1><blockquote>
<p>只需要在配置菜单的时候配置上准入身份，在登录成功以后获取到登陆者身份以后更新登录人身份参数即可</p>
</blockquote>
<h2 id="权限组件-Authorized"><a href="#权限组件-Authorized" class="headerlink" title="权限组件 Authorized"></a>权限组件 Authorized</h2><blockquote>
<p>这是脚手架权限管理的基础，基本思路是通过比对当前权限与准入权限，决定展示正常渲染内容还是异常内容</p>
</blockquote>
<p><strong>控制菜单和路由显示</strong></p>
<blockquote>
<p>如需对某些页面进行权限控制，只须在路由配置文件 <code>router.config.js</code> 中设置 <code>authority</code> 属性即可，代表该路由的准入权限，pro 的路由系统中会默认包裹 <code>Authorized</code> 进行判断处理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/form&#x27;,</span><br><span class="line">  icon: &#x27;form&#x27;,</span><br><span class="line">  name: &#x27;form&#x27;,</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path: &#x27;/form/basic-form&#x27;,</span><br><span class="line">    name: &#x27;basicform&#x27;,</span><br><span class="line">    component: &#x27;./Forms/BasicForm&#x27;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &#x27;/form/step-form&#x27;,</span><br><span class="line">    name: &#x27;stepform&#x27;,</span><br><span class="line">    component: &#x27;./Forms/StepForm&#x27;,</span><br><span class="line">    authority: [&#x27;guest&#x27;], // 配置准入权限，可以配置多个角色</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &#x27;/form/advanced-form&#x27;,</span><br><span class="line">    name: &#x27;advancedform&#x27;,</span><br><span class="line">    component: &#x27;./Forms/AdvancedForm&#x27;,</span><br><span class="line">    authority: [&#x27;admin&#x27;], // 配置准入权限，可以配置多个角色</span><br><span class="line">  &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制页面元素显示"><a href="#控制页面元素显示" class="headerlink" title="控制页面元素显示"></a>控制页面元素显示</h2><blockquote>
<p>使用 <code>Authorized</code> 或<code>Authorized.Secured</code> 可以很方便地控制元素/组件的渲染。<a target="_blank" rel="noopener" href="https://pro.ant.design/components/Authorized#Authorized.Secured">https://pro.ant.design/components/Authorized#Authorized.Secured</a></p>
</blockquote>
<h2 id="demo关于权限简介"><a href="#demo关于权限简介" class="headerlink" title="demo关于权限简介"></a>demo关于权限简介</h2><ul>
<li>用邮箱自己注册账户（注册后可以登录但是没有任何权限）<code>guest</code></li>
<li>联系管理员分配权限（分配后可以查看有权限的页面）</li>
<li>每次登录后获取最新的权限身份（如：<code>admin</code>，<code>user</code>，<code>guest</code>）</li>
</ul>
<blockquote>
<p>在<code>src/router.js</code>中会发现如下代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;AuthorizedRoute</span><br><span class="line">    path=&quot;/&quot;</span><br><span class="line">    render=&#123;props =&gt; &lt;BasicLayout &#123;...props&#125; /&gt;&#125;</span><br><span class="line">    authority=&#123;[&#x27;admin&#x27;, &#x27;user&#x27;, &#x27;guest&#x27;]&#125;</span><br><span class="line">    redirectPath=&quot;/user/login&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>authority</code>对象就是准入身份的数组，表示只有这些身份的人可以登录，我们在配置的时候一定不要忘记在这更新我们新增的身份</p>
</blockquote>
<ul>
<li>然后就是<code>menu.js</code>,如下，展示了我们在配置菜单的时候怎么配身份</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const menuData = [&#123;</span><br><span class="line">  name: &#x27;题库管理&#x27;,</span><br><span class="line">  path: &#x27;question&#x27;,</span><br><span class="line">  icon: &#x27;warning&#x27;,</span><br><span class="line">  authority: [&#x27;admin&#x27;, &#x27;user&#x27;],</span><br><span class="line">  children: [&#123;</span><br><span class="line">    name: &#x27;题库列表&#x27;,</span><br><span class="line">    path: &#x27;list&#x27;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#x27;编辑题目&#x27;,</span><br><span class="line">    path: &#x27;create-question&#x27;,</span><br><span class="line">    hideInMenu: true,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#x27;科目管理&#x27;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &#x27;账号管理&#x27;,</span><br><span class="line">  icon: &#x27;warning&#x27;,</span><br><span class="line">  path: &#x27;account&#x27;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    name: &#x27;账号列表&#x27;,</span><br><span class="line">    path: &#x27;list&#x27;,</span><br><span class="line">    authority: &#x27;admin&#x27;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &#x27;建设中&#x27;,</span><br><span class="line">    path: &#x27;&#x27;,</span><br><span class="line">    authority: [&#x27;admin&#x27;, &#x27;user&#x27;],</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>登录成功以后怎么获取权限了</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">effects：&#123;</span><br><span class="line">* login(&#123;payload&#125;, &#123;call, put&#125;) &#123;</span><br><span class="line">      const response = yield call(login, payload);</span><br><span class="line">      yield put(&#123;</span><br><span class="line">        type: &#x27;changeLoginStatus&#x27;,</span><br><span class="line">        payload: response,</span><br><span class="line">      &#125;);</span><br><span class="line">      // 登录成功以后更新权限，跳转页面</span><br><span class="line">      if (response &amp;&amp; response.code === &#x27;0000&#x27;) &#123;</span><br><span class="line">        reloadAuthorized();</span><br><span class="line">        yield put(routerRedux.push(&#x27;/&#x27;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;，</span><br><span class="line">reducers: &#123;</span><br><span class="line">    changeLoginStatus(state, &#123;payload&#125;) &#123;</span><br><span class="line">      let _status = &quot;ok&quot;;</span><br><span class="line">      let _user = &quot;admin&quot;;</span><br><span class="line">      setToken(&quot;token&quot;);</span><br><span class="line">      setAuthority(_user);//设置权限</span><br><span class="line">      return &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        status: _status,</span><br><span class="line">        type: &#x27;account&#x27;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们看看<code>setAuthority</code>、<code>reloadAuthorized</code>这两个方法都做了什么事儿</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置身份</span><br><span class="line">export function setAuthority(authority) &#123;</span><br><span class="line">  return localStorage.setItem(&#x27;antd-pro-authority&#x27;, authority);</span><br><span class="line">&#125;</span><br><span class="line">//获取身份</span><br><span class="line">export function getAuthority() &#123;</span><br><span class="line">  return localStorage.getItem(&#x27;antd-pro-authority&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如此而且，只是把新的身份值存在<code>localStorage</code>里边，注意<code>getAuthority</code>，下边会用到</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import RenderAuthorized from &#x27;../components/Authorized&#x27;;</span><br><span class="line">import &#123; getAuthority &#125; from &#x27;./authority&#x27;;</span><br><span class="line">let Authorized = RenderAuthorized(getAuthority());</span><br><span class="line">const reloadAuthorized = () =&gt; &#123;</span><br><span class="line">  Authorized = RenderAuthorized(getAuthority());</span><br><span class="line">&#125;;</span><br><span class="line">export &#123; reloadAuthorized &#125;;</span><br><span class="line">export default Authorized;</span><br><span class="line">RenderAuthorized: (currentAuthority: string | () =&gt; string) =&gt; Authorized</span><br></pre></td></tr></table></figure>

<blockquote>
<p>权限组件默认 <code>export RenderAuthorized</code> 函数，它接收当前权限作为参数，返回一个权限对象，该对象提供以下几种使用方式</p>
</blockquote>
<p><strong>Authorized</strong></p>
<blockquote>
<p>最基础的权限控制</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>children</code></td>
<td align="left">正常渲染的元素，权限判断通过时展示</td>
</tr>
<tr>
<td align="left"><code>authority</code></td>
<td align="left">准入权限/权限判断</td>
</tr>
<tr>
<td align="left"><code>noMatch</code></td>
<td align="left">权限异常渲染元素，权限判断不通过时展示</td>
</tr>
</tbody></table>
<p><strong>Authorized.AuthorizedRoute</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>authority</code></td>
<td align="left">准入权限/权限判断</td>
</tr>
<tr>
<td align="left"><code>redirectPath</code></td>
<td align="left">权限异常时重定向的页面路由</td>
</tr>
</tbody></table>
<p><strong>Authorized.Secured</strong></p>
<blockquote>
<p>注解方式，[<code>@Authorized.Secured](mailto:</code>@Authorized.Secured)(authority, error)`</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>authority</code></td>
<td align="left">准入权限/权限判断</td>
</tr>
<tr>
<td align="left"><code>error</code></td>
<td align="left">权限异常时渲染元素</td>
</tr>
</tbody></table>
<p><strong>Authorized.check</strong></p>
<blockquote>
<p>函数形式的 <code>Authorized</code>，用于某些不能被 <code>HOC</code> 包裹的组件。 <code>Authorized.check(authority, target, Exception)</code></p>
</blockquote>
<ul>
<li>注意：传入一个 <code>Promise</code> 时，无论正确还是错误返回的都是一个 <code>ReactClass</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>authority</code></td>
<td align="left">准入权限/权限判断</td>
</tr>
<tr>
<td align="left"><code>target</code></td>
<td align="left">权限判断通过时渲染的元素</td>
</tr>
<tr>
<td align="left"><code>Exception</code></td>
<td align="left">权限异常时渲染元素</td>
</tr>
</tbody></table>
<h1 id="十五、构建和发布"><a href="#十五、构建和发布" class="headerlink" title="十五、构建和发布"></a>十五、构建和发布</h1><p><strong>构建</strong></p>
<blockquote>
<p>当项目开发完毕，只需要运行一行命令就可以打包你的应用：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 Ant Design Pro 使用的工具 Umi 已经将复杂的流程封装完毕，构建打包文件只需要一个命令 umi build，构建打包成功之后，会在根目录生成 dist 文件夹，里面就是构建打包好的文件，通常是 <em>.js、</em>.css、index.html 等静态文件</p>
</blockquote>
<p><strong>分析构建文件体积</strong></p>
<blockquote>
<p>如果你的构建文件很大，你可以通过 analyze 命令构建并分析依赖模块的体积分布，从而优化你的代码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run analyze</span><br></pre></td></tr></table></figure>

<p><strong>发布</strong></p>
<blockquote>
<p>对于发布来讲，只需要将最终生成的静态文件，也就是通常情况下 dist 文件夹的静态文件发布到你的 cdn 或者静态服务器即可，需要注意的是其中的 <code>index.html</code> 通常会是你后台服务的入口页面，在确定了 js 和 css 的静态之后可能需要改变页面的引入路径</p>
</blockquote>
<p><strong>前端路由与服务端的结合</strong></p>
<blockquote>
<p>Ant Design Pro 使用的 Umi 支持两种路由方式：<code>browserHistory</code> 和 <code>hashHistory</code>。</p>
</blockquote>
<ul>
<li>可以在 <code>config/config.js</code> 中进行配置选择用哪个方式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  history: &#x27;hash&#x27;, // 默认是 browser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十六、一些问题"><a href="#十六、一些问题" class="headerlink" title="十六、一些问题"></a>十六、一些问题</h1><h2 id="在ant-design-pro中解决跨域办法"><a href="#在ant-design-pro中解决跨域办法" class="headerlink" title="在ant-design-pro中解决跨域办法"></a>在ant-design-pro中解决跨域办法</h2><blockquote>
<p>需要在配置文件中(<code>.webpackrc</code>)加入如下代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;http://xxx:xx/&quot;,</span><br><span class="line">    &quot;changeOrigin&quot;: true,</span><br><span class="line">    &quot;pathRewrite&quot;: &#123; &quot;^/api&quot; : &quot;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是此处不是将<code>/api/</code>代理到正式请求<code>/api/</code>中，（例如请求<code>/api/users</code>则会代理到<code>http://xxx:xx/users</code>）<br>如果需要多次代理且需要代理到不同的服务器则可以在配置文件中进行如下配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">      &quot;/test&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;http://xxx:xx/&quot;,</span><br><span class="line">        &quot;changeOrigin&quot;: true,</span><br><span class="line">        &quot;pathRewrite&quot;: &#123; &quot;^/test&quot; : &quot;&quot; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;/cross&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com&quot;,</span><br><span class="line">        &quot;changeOrigin&quot;: true,</span><br><span class="line">        &quot;pathRewrite&quot;: &#123;&quot;^/cross&quot;: &quot;&quot;&#125;</span><br><span class="line">      &#125; // 此处有一点需要注意，不能在最后一个代理对象后面加逗号，否则会报错！！！</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="在model中怎么同时发起多次请求"><a href="#在model中怎么同时发起多次请求" class="headerlink" title="在model中怎么同时发起多次请求"></a>在model中怎么同时发起多次请求</h2><blockquote>
<p>因为<code>yield</code>将异步请求转为同步请求了，所以请求会按照同步顺序依次执行，使请求时间延长</p>
</blockquote>
<p><strong>错误写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// effects将按顺序执行</span><br><span class="line">const response = yield call(fetch, &#x27;/users&#x27;);</span><br><span class="line">const res = yield call(fetch, &#x27;/roles&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>正确写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// effects将会同步执行</span><br><span class="line">const [response, res] = yield [</span><br><span class="line">  call(fetch, &#x27;/users&#x27;),</span><br><span class="line">  call(fetch, &#x27;/roles&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/23/React-context/">React context</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>React</code> 组件之间的通信是基于 <code>props</code> 的单向数据流，即父组件通过 <code>props</code> 向子组件传值，亦或是子组件执行传入的函数来更新父组件的<code>state</code>，这都满足了我们大部分的使用场景</li>
<li>一般地，对于兄弟组件之间的通信，是通过它们共同的祖先组件进行的，即 Lifting State Up，官方文档也有介绍。组件一通过事件将状态变更通知它们共同的祖先组件，祖先组再将状态同步到组件二</li>
<li>但是，如果组件之间嵌套的比较深，即使提升状态到共同父组件，再同步状态到相应的组件还是需要一层一层的传递下去，可能会比较繁琐</li>
<li>在对应的场景中，<code>context</code> 就可以缩短父组件到子组件的属性传递路径</li>
</ul>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import Parent from &#x27;./Parent&#x27;</span><br><span class="line">import ChildOne from &#x27;../components/ChildOne&#x27;</span><br><span class="line">import ChildTwo from &#x27;../components/ChildTwo&#x27;</span><br><span class="line"></span><br><span class="line">export default class Container extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123; value: &#x27;&#x27; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    changeValue = value =&gt; &#123;</span><br><span class="line">        this.setState(&#123; value &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: this.state.value,</span><br><span class="line">            changeValue: this.changeValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Parent&gt;</span><br><span class="line">                    &lt;ChildOne /&gt;</span><br><span class="line">                &lt;/Parent&gt;</span><br><span class="line">                &lt;Parent&gt;</span><br><span class="line">                    &lt;ChildTwo /&gt;</span><br><span class="line">                &lt;/Parent&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Container.childContextTypes = &#123;</span><br><span class="line">    value: PropTypes.string,</span><br><span class="line">    changeValue: PropTypes.func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parent.jsx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">const Parent = (props) =&gt; (</span><br><span class="line">    &lt;div &#123;...props&#125; /&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Parent</span><br></pre></td></tr></table></figure>

<p>ChildOne.jsx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default class ChildOne extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    handleChange = (e) =&gt; &#123;</span><br><span class="line">        const &#123; changeValue &#125; = this.context</span><br><span class="line">        changeValue(e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                子组件一</span><br><span class="line">                &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildOne.contextTypes = &#123;</span><br><span class="line">    changeValue: PropTypes.func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChildTwo.jsx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default class ChildTwo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                子组件二</span><br><span class="line">                &lt;p&gt;&#123;this.context.value&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChildTwo.contextTypes = &#123;</span><br><span class="line">    value: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>Container.childContextTypes</code> 中进行接口的声明，通过 <code>getChildContext</code> 返回更新后的<code>state</code>，在 <code>Child.contextTypes</code> 中声明要获取的接口，这样在子组件内部就能通过 <code>this.context</code> 获取到。通过 <code>Context</code> 这样一个中间对象，<code>ChildOne</code> 和 <code>ChildTwo</code> 就可以相互通信了</p>
</blockquote>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><blockquote>
<p>组件嵌套传递属性，在导航里面引用<code>Page</code>中的变量</p>
</blockquote>
<ul>
<li>使用<code>context</code>来传递</li>
<li>使用props层级传递</li>
</ul>
<blockquote>
<p>使用<code>context</code>组件需要定义<code>propTypes</code>,需要严格校验、声明类型、字段</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Page extends React.Component &#123;</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">       user:PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;user:&#x27;poetries&#x27;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getChildContext()&#123;</span><br><span class="line">        return this.state</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;我是&#123;this.state.user&#125;&lt;/p&gt;</span><br><span class="line">            &lt;Siderbar /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Siderbar extends React.Component &#123;</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">       user:PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;侧边栏&lt;/p&gt;</span><br><span class="line">            &lt;Navbar /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Navbar extends React.Component &#123;</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">       user:PropTypes.string</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;我是&#123;this.context.user&#125;的导航栏&lt;/p&gt;</span><br><span class="line">            &lt;Siderbar /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context在Provider种应用"><a href="#context在Provider种应用" class="headerlink" title="context在Provider种应用"></a>context在Provider种应用</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider`组件就是使用`context`，把`store`放到`context`里，所有的子元素可以直接取到`store</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &#x27;prop-types&#x27;</span><br><span class="line">class Provider extends Component &#123;</span><br><span class="line">    static childContextTypes = &#123;</span><br><span class="line">        store:Protypes.object</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props,context)&#123;</span><br><span class="line">        super(props,context)</span><br><span class="line">        this.store = props.store</span><br><span class="line">    &#125;</span><br><span class="line">    getChildContext()&#123;</span><br><span class="line">        //把传进来的store放进全局</span><br><span class="line">        return &#123;store:this.store&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return this.props.children</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>connect</code> 负责连接组件，给到<code>redux</code>里的数据放到组件的属性里</p>
</blockquote>
<ul>
<li>负责接收一个组件，把<code>state</code>里的一些数据放进去，返回一个组件</li>
<li>数据变化的时候，能够通知组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//高阶组件写法</span><br><span class="line">const connect = (mapStateToProps=state=&gt;state,mapDispatchToProps=&#123;&#125;)=&gt;(wrapperComponent)=&gt;&#123;</span><br><span class="line">    return class ConnectComponent extends React.Component &#123;</span><br><span class="line">        //负责接收组件</span><br><span class="line">        static contextTypes = &#123;</span><br><span class="line">            store:PropTypes.obejct</span><br><span class="line">        &#125;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props, context)&#123;</span><br><span class="line">                this.state = &#123;</span><br><span class="line">                    props:&#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount()&#123;</span><br><span class="line">            const &#123;store&#125; = this.context</span><br><span class="line">            store.subscribe(()=&gt;this.update())</span><br><span class="line">            this.update()</span><br><span class="line">        &#125;</span><br><span class="line">        update()&#123;</span><br><span class="line">            //  获取mapStateToProps、mapDispatchToProps 放入this.props里</span><br><span class="line">            </span><br><span class="line">            const &#123;store&#125;=this.context</span><br><span class="line">            const stateProps = mapStateToProps(store.getState())</span><br><span class="line">            const dispatchProps = bindActionCreators(mapDispatchProps,store.dispatch)</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                props:&#123;</span><br><span class="line">                    ...this.state.props,</span><br><span class="line">                    ...stateProps,</span><br><span class="line">                    ...dispatchProps</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            // 把数据放入</span><br><span class="line">            return &lt;wrapperComponent &#123;...this.state.props&#125;/&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/23/Redux-action%E5%BC%82%E6%AD%A5/">Redux action异步</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Redux/">Redux</a></span><div class="content"><h2 id="一、创建同步Action"><a href="#一、创建同步Action" class="headerlink" title="一、创建同步Action"></a>一、创建同步Action</h2><blockquote>
<p><code>Action</code>是数据从应用传递到 <code>store</code>/<code>state</code> 的载体，也是开启一次完成数据流的开始</p>
</blockquote>
<p><strong>普通的action对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const action = &#123;</span><br><span class="line">	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">	name:&#x27;poetries&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(action)</span><br></pre></td></tr></table></figure>

<p><strong>封装action creator</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function actionCreator(data)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    	type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">    	data:data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch(actionCreator(&#x27;poetries&#x27;))</span><br></pre></td></tr></table></figure>

<p><strong>bindActionCreators合并</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function a(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;a&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">function b(name,id)&#123;</span><br><span class="line">	reurn &#123;</span><br><span class="line">		type:&#x27;b&#x27;,</span><br><span class="line">		name,</span><br><span class="line">		id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">actions.a(&#x27;poetries&#x27;,&#x27;id001&#x27;)</span><br><span class="line">actions.b(&#x27;jing&#x27;,&#x27;id002&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>action创建的标准</strong></p>
<blockquote>
<p>在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件</p>
</blockquote>
<ul>
<li>是一个纯文本对象</li>
<li>只具备 <code>type</code> 、<code>payload</code>、<code>error</code> 和 <code>meta</code>中的一个或者多个属性。<code>type</code> 字段不可缺省，其它字段可缺省</li>
<li>若 <code>Action</code> 报错，<code>error</code> 字段不可缺省，切必须为 <code>true</code></li>
</ul>
<blockquote>
<p><code>payload</code> 是一个对象，用作Action携带数据的载体</p>
</blockquote>
<p><strong>标准action示例</strong></p>
<ul>
<li>A basic Flux Standard Action:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    text: &#x27;Do something.&#x27;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>An FSA that represents an error, analogous to a rejected Promise</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">  payload: new Error(),</span><br><span class="line">  error: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/acdlite/flux-standard-action">https://github.com/acdlite/flux-standard-action</a></p>
</blockquote>
<ul>
<li>可以采用如下一个简单的方式检验一个<code>Action</code>是否符合FSA标准</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// every有一个匹配不到返回false</span><br><span class="line">let isFSA = Object.keys(action).every((item)=&gt;&#123;</span><br><span class="line">   return  [&#x27;payload&#x27;,&#x27;type&#x27;,&#x27;error&#x27;,&#x27;meta&#x27;].indexOf(item) &gt;  -1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="二、创建异步action的多种方式"><a href="#二、创建异步action的多种方式" class="headerlink" title="二、创建异步action的多种方式"></a>二、创建异步action的多种方式</h2><blockquote>
<p>最简单的方式就是使用同步的方式来异步，将原来同步时一个<code>action</code>拆分成多个异步的<code>action</code>的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有<code>redux-saga</code>等插件来解决这些问题了</p>
</blockquote>
<p><strong>异步action的实现方式一：setTimeout</strong></p>
<blockquote>
<p><code>redux-thunk</code>中间处理解析</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function thunkAction(data) &#123;</span><br><span class="line">    reutrn (dispatch)=&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异步action的实现方式二：promise实现异步action</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise`中间处理这种`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function promiseAction(name)&#123;</span><br><span class="line">    return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">        setTimeout((param)=&gt;&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                type:&#x27;ADD_TODO&#x27;,</span><br><span class="line">                name</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action2&quot;))</span><br><span class="line">        return;</span><br><span class="line">    &#125;).then((param)=&gt;&#123;</span><br><span class="line">        dispatch(action(&quot;action3&quot;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、redux异步流程"><a href="#三、redux异步流程" class="headerlink" title="三、redux异步流程"></a>三、redux异步流程</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/492.png" alt="img"></p>
<ul>
<li>首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样<code>dispatch</code>的返回值才能是一个函数。</li>
<li>通过<code>store.dispatch</code>，将状态的的改变传给<code>store</code>的小弟<code>reducer</code>，<code>reducer</code>根据<code>action</code>的改变，传递新的状态<code>state</code>。</li>
<li>最后将所有的改变告诉给它的大哥，<code>store</code>。<code>store</code>保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了</li>
</ul>
<h2 id="四、Redux异步方案选型"><a href="#四、Redux异步方案选型" class="headerlink" title="四、Redux异步方案选型"></a>四、Redux异步方案选型</h2><p><strong>redux-thunk</strong></p>
<blockquote>
<p><code>Redux</code>本身只能处理同步的<code>Action</code>，但可以通过中间件来拦截处理其它类型的<code>action</code>，比如函数(<code>Thunk</code>)，再用回调触发普通<code>Action</code>，从而实现异步处理</p>
</blockquote>
<ul>
<li>发送异步的<code>action</code>其实是被中间件捕获的，函数类型的action就被<code>middleware</code>捕获。至于怎么定义异步的<code>action</code>要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析<code>action</code></li>
</ul>
<blockquote>
<p><code>Redux</code> 本身不处理异步行为，需要依赖中间件。结合 <code>redux-actions</code> 使用，<code>Redux</code> 有两个推荐的异步中间件</p>
</blockquote>
<ul>
<li><code>redux-thunk</code></li>
<li><code>redux-promise</code></li>
</ul>
<blockquote>
<p><code>redux-thunk</code> 的源码如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">    if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>源码可知，<code>action creator</code> 需要返回一个函数给 <code>redux-thunk</code> 进行调用，示例如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123;</span><br><span class="line">    //请求之前的一些处理</span><br><span class="line"></span><br><span class="line">    let value = await Promise.resolve(val + &#x27; thunk&#x27;);</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">        type:CONSTANT.ADD_TO_DO_THUNK,</span><br><span class="line">        payload:&#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>而它使用起来最大的问题，就是重复的模板代码太多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_SUCCESS = &#x27;GET_DATA_SUCCESS&#x27;,</span><br><span class="line">    GET_DATA_FAILED = &#x27;GET_DATA_FAILED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: GET_DATA, </span><br><span class="line">            payload: id</span><br><span class="line">        &#125;)</span><br><span class="line">        api.getData(id) //注：本文所有示例的api.getData都返回promise对象</span><br><span class="line">            .then(response =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_SUCCESS,</span><br><span class="line">                    payload: response</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(error =&gt; &#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GET_DATA_FAILED,</span><br><span class="line">                    payload: error</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = (oldState, action) =&gt; &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA : </span><br><span class="line">        return oldState;</span><br><span class="line">    case GET_DATA_SUCCESS : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_FAILED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍</p>
</blockquote>
<ul>
<li>另一方面，像<code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>这样的字符串声明也非常无趣且易错<br>上例中，<code>GET_DATA</code>这个<code>action</code>并不是多数场景需要的</li>
</ul>
<p><strong>redux-promise</strong></p>
<blockquote>
<p>由于<code>redux-thunk</code>写起来实在是太麻烦了，社区当然会有其它轮子出现。<code>redux-promise</code>则是其中比较知名的</p>
</blockquote>
<ul>
<li><p>它自定义了一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">middleware</span><br></pre></td></tr></table></figure>

<p>，当检测到有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br></pre></td></tr></table></figure>

<p>属性是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br></pre></td></tr></table></figure>

<p>对象时，就会</p>
<ul>
<li>若<code>resolve</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>value</code>，并设<code>status</code>属性为<code>&quot;success&quot;</code></li>
<li>若<code>reject</code>，触发一个此<code>action</code>的拷贝，但<code>payload</code>为<code>promise</code>的<code>reason</code>，并设<code>status</code>属性为<code>&quot;error&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;;</span><br><span class="line"></span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: api.getData(id) //payload为promise对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">function reducer(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">        case GET_DATA: </span><br><span class="line">            if (action.status === &#x27;success&#x27;) &#123;</span><br><span class="line">                return successState</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                   return errorState</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>redux-promise</code>为了精简而做出的妥协非常明显：无法处理乐观更新</p>
</blockquote>
<p><strong>场景解析之：乐观更新</strong></p>
<blockquote>
<p>多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据</p>
</blockquote>
<ul>
<li>由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作</li>
<li>在上面<code>redux-thunk</code>的例子中，我们看到了<code>GET_DATA</code>, <code>GET_DATA_SUCCESS</code>、<code>GET_DATA_FAILED</code>三个<code>action</code>，分别表示初始动作、异步成功和异步失败，其中第一个<code>action</code>使得<code>redux-thunk</code>具备乐观更新的能力</li>
<li>而在<code>redux-promise</code>中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，<code>redux</code>认可的<code>action</code>对象是 <code>plain JavaScript objects</code>，即简单对象，而在<code>redux-promise</code>中，初始<code>action</code>的<code>payload</code>是个<code>Promise</code></li>
</ul>
<p><strong>redux-promise-middleware</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redux-promise-middleware`相比`redux-promise`，采取了更为温和和渐进式的思路，保留了和`redux-thunk`类似的三个`action</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//action types</span><br><span class="line">const GET_DATA = &#x27;GET_DATA&#x27;,</span><br><span class="line">    GET_DATA_PENDING = &#x27;GET_DATA_PENDING&#x27;,</span><br><span class="line">    GET_DATA_FULFILLED = &#x27;GET_DATA_FULFILLED&#x27;,</span><br><span class="line">    GET_DATA_REJECTED = &#x27;GET_DATA_REJECTED&#x27;;</span><br><span class="line">    </span><br><span class="line">//action creator</span><br><span class="line">const getData = function(id) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: GET_DATA,</span><br><span class="line">        payload: &#123;</span><br><span class="line">            promise: api.getData(id),</span><br><span class="line">            data: id</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//reducer</span><br><span class="line">const reducer = function(oldState, action) &#123;</span><br><span class="line">    switch(action.type) &#123;</span><br><span class="line">    case GET_DATA_PENDING :</span><br><span class="line">        return oldState; // 可通过action.payload.data获取id</span><br><span class="line">    case GET_DATA_FULFILLED : </span><br><span class="line">        return successState;</span><br><span class="line">    case GET_DATA_REJECTED : </span><br><span class="line">        return errorState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、redux异步操作代码演示"><a href="#五、redux异步操作代码演示" class="headerlink" title="五、redux异步操作代码演示"></a>五、redux异步操作代码演示</h2><ul>
<li>根据官网的async例子分析 <a target="_blank" rel="noopener" href="https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async">https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async</a></li>
</ul>
<p><strong>action/index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import fetch from &#x27;isomorphic-fetch&#x27;</span><br><span class="line">export const RECEIVE_POSTS = &#x27;RECEIVE_POSTS&#x27;</span><br><span class="line"></span><br><span class="line">//获取新闻成功的action</span><br><span class="line">function receivePosts(reddit, json) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    reddit: reddit,</span><br><span class="line">    posts: json.data.children.map(child =&gt;child.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetchPosts(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return function (dispatch) &#123;</span><br><span class="line">    </span><br><span class="line">    return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`)</span><br><span class="line">      .then(response =&gt; response.json())</span><br><span class="line">      .then(json =&gt;</span><br><span class="line">        dispatch(receivePosts(subreddit, json))</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要则开始获取文章</span><br><span class="line">export function fetchPostsIfNeeded(subreddit) &#123;</span><br><span class="line"></span><br><span class="line">  return (dispatch, getState) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">      return dispatch(fetchPosts(subreddit))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fetchPostsIfNeeded</code>这里就是一个中间件。<code>redux-thunk</code>会拦截<code>fetchPostsIfNeeded</code>这个<code>action</code>，会先发起数据请求，如果成功，就将数据传给<code>action</code>从而到达<code>reducer</code>那里</p>
</blockquote>
<p><strong>reducers/index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import &#123;</span><br><span class="line">  RECEIVE_POSTS</span><br><span class="line">&#125; from &#x27;../actions&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function posts(state = &#123;</span><br><span class="line">  items: []</span><br><span class="line">&#125;, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line"></span><br><span class="line">    case RECEIVE_POSTS:</span><br><span class="line">      // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里</span><br><span class="line">      //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span><br><span class="line">      return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        items: action.posts //数据都存在了这里</span><br><span class="line">      &#125;)</span><br><span class="line">    default:</span><br><span class="line">      return state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将所有的reducer结合为一个,传给store</span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  postsByReddit</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default rootReducer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个跟正常的<code>reducer</code>差不多。判断<code>action</code>的类型，从而根据<code>action</code>的不同类型，返回不同的数据。这里将数据存储在了<code>items</code>这里。这里的<code>reducer</code>只有一个。最后结合成<code>rootReducer</code>,传给<code>store</code></p>
</blockquote>
<p><strong>store/configureStore.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;</span><br><span class="line">import thunkMiddleware from &#x27;redux-thunk&#x27;</span><br><span class="line">import createLogger from &#x27;redux-logger&#x27;</span><br><span class="line">import rootReducer from &#x27;../reducers&#x27;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">  thunkMiddleware,  </span><br><span class="line">  createLogger()  </span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line">export default function configureStore(initialState) &#123;</span><br><span class="line">  const store = createStoreWithMiddleware(rootReducer, initialState)</span><br><span class="line"></span><br><span class="line">  if (module.hot) &#123;</span><br><span class="line">    // Enable Webpack hot module replacement for reducers</span><br><span class="line">    module.hot.accept(&#x27;../reducers&#x27;, () =&gt; &#123;</span><br><span class="line">      const nextRootReducer = require(&#x27;../reducers&#x27;)</span><br><span class="line">      store.replaceReducer(nextRootReducer)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们是如何在 <code>dispatch</code> 机制中引入 <code>Redux Thunk middleware</code> 的呢？<br>我们使用了<code>applyMiddleware()</code></li>
<li>通过使用指定的 <code>middleware</code>，<code>action creator</code> 除了返回 <code>action</code> 对象外还可以返回函数</li>
<li>这时，这个 <code>action creator</code> 就成为了 <code>thunk</code></li>
</ul>
<p><strong>界面上的调用：在containers/App.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化渲染后触发</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch&#125; = this.props</span><br><span class="line">    // 这里可以传两个值，一个是 reactjs 一个是 frontend</span><br><span class="line">    dispatch(fetchPostsIfNeeded(&#x27;frontend&#x27;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>改变状态的时候也是需要通过<code>dispatch</code>来传递的</p>
</blockquote>
<ul>
<li>数据的获取是通过<code>provider</code>,将<code>store</code>里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;babel-core/polyfill&#x27;</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import &#123; render &#125; from &#x27;react-dom&#x27;</span><br><span class="line">import &#123; Provider &#125; from &#x27;react-redux&#x27;</span><br><span class="line">import App from &#x27;./containers/App&#x27;</span><br><span class="line">import configureStore from &#x27;./store/configureStore&#x27;</span><br><span class="line">const store = configureStore()</span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样就完成了<code>redux</code>的异步操作。其实最主要的区别还是<code>action</code>里面还有中间件的调用，其他的地方基本跟同步的<code>redux</code>差不多的。搞懂了中间件，就基本搞懂了<code>redux</code>的异步操作</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/493.png" alt="img"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">React性能优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、重新认识render"><a href="#一、重新认识render" class="headerlink" title="一、重新认识render"></a>一、重新认识render</h2><blockquote>
<p><code>react</code>的组件渲染分为初始化渲染和更新渲染</p>
</blockquote>
<ul>
<li>在初始化渲染的时候会调用根组件下的所有组件的<code>render</code>方法进行渲染，如下图（绿色表示已渲染，这一层是没有问题的）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/420.png" alt="img"></p>
<p>但是当我们要更新某个子组件的时候，如下图的绿色组件（从根组件传递下来应用在绿色组件上的数据发生改变）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/421.png" alt="img"></p>
<p>我们的理想状态是只调用关键路径上组件的render</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/422.png" alt="img"></p>
<p>但是<code>react</code>的默认做法是调用所有组件的<code>render</code>，再对生成的虚拟<code>DOM</code>进行对比，如不变则不进行更新。这样的<code>render</code>和虚拟<code>DOM</code>的 对比 明显是在浪费，如下图（黄色表示浪费的<code>render</code>和虚拟<code>DOM</code>对比）</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/423.png" alt="img"></p>
<p><strong>Tips</strong></p>
<ul>
<li>拆分组件是有利于复用和组件优化的</li>
<li>生成虚拟<code>DOM</code>并进行比对发生在<code>render()</code>后，而不是<code>render()</code>前</li>
</ul>
<h2 id="二、更新阶段的生命周期"><a href="#二、更新阶段的生命周期" class="headerlink" title="二、更新阶段的生命周期"></a>二、更新阶段的生命周期</h2><ul>
<li><code>componentWillReceiveProps(object nextProps)</code> ：当挂载的组件接收到新的<code>props</code>时被调用。此方法应该被用于比较<code>this.props</code> 和 <code>nextProps</code>以用于使用<code>this.setState()</code>执行状态转换。（组件内部数据有变化，使用<code>state</code>，但是在更新阶段又要在<code>props</code>改变的时候改变<code>state</code>，则在这个生命周期里面）</li>
<li><code>shouldComponentUpdate(object nextProps, object nextState)</code> ： -<code>boolean</code> 当组件决定任何改变是否要更新到<code>DOM</code>时被调用。作为一个 优化 实现比较<code>this.props</code> 和 <code>nextProps</code> 、<code>this.state</code> 和 <code>nextState</code> ，如果<code>React</code>应该跳过更新，返回<code>false</code></li>
<li><code>componentWillUpdate(object nextProps, object nextState</code>) ：在更新发生前被立即调用。你不能在此调用 <code>this.setState()</code></li>
<li><code>componentDidUpdate(object prevProps, object prevState</code>) ： 在更新发生后被立即调用。（可以在<code>DOM</code>更新完之后，做一些收尾的工作）</li>
</ul>
<p><strong>Tips</strong></p>
<ul>
<li><code>React</code>的优化是基于 <code>shouldComponentUpdate</code> 的，该生命周期默认返回<code>true</code>，所以一旦<code>prop</code>或<code>state</code>有任何变化，都会引起重新<code>render</code></li>
</ul>
<h2 id="三、shouldComponentUpdate"><a href="#三、shouldComponentUpdate" class="headerlink" title="三、shouldComponentUpdate"></a>三、shouldComponentUpdate</h2><blockquote>
<p><code>react</code>在每个组件生命周期更新的时候都会调用一个<code>shouldComponentUpdate(nextProps, nextState)</code>函数。它的职责就是返回<code>true</code>或<code>false</code>，true表示需要更新，<code>false</code>表示不需要，默认返回为<code>true</code>，即便你没有显示地定义 <code>shouldComponentUpdate</code> 函数。这就不难解释上面发生的资源浪费了</p>
</blockquote>
<p><strong>带坑的写法</strong></p>
<ul>
<li><code>&#123;...this.props&#125;</code> (不要滥用，请只传递<code>component</code>需要的<code>props</code>，传得太多，或者层次传得太深，都会加重<code>shouldComponentUpdate</code>里面的数据比较负担，因此，也请慎用<code>spread attributes（）)</code></li>
<li><code>::this.handleChange()。(请将方法的bind一律置于constructor)</code></li>
<li>复杂的页面不要在一个组件里面写完</li>
<li>请尽量使用<code>const element</code></li>
<li><code>map</code>里面添加<code>key</code>，并且<code>key</code>不要使用<code>index</code>（可变的)</li>
<li>尽量少用<code>setTimeOut</code>或不可控的<code>refs</code>、<code>DOM</code>操作</li>
<li>数据尽可能简单明了，扁平化</li>
</ul>
<h2 id="四、性能检测工具"><a href="#四、性能检测工具" class="headerlink" title="四、性能检测工具"></a>四、性能检测工具</h2><p><strong>React.addons.Perf</strong></p>
<blockquote>
<p><code>react</code>官方提供一个插件 <code>React.addons.Perf</code> 可以帮助我们分析组件的性能，以确定是否需要优化</p>
</blockquote>
<p><code>react16</code>以前需要在项目中配置，<code>react16</code>以后请看这篇文章，直接打开控制台的<code>perf</code>选项测试 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab">https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab</a></p>
<p><strong>react16之前配置</strong></p>
<ul>
<li>安装 <code>react</code> 性能检测工具 <code>npm i react-addons-perf --save</code>，然后在<code>./app/index.js</code>中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 性能测试</span><br><span class="line">import Perf from &#x27;react-addons-perf&#x27;</span><br><span class="line">if (__DEV__) &#123;</span><br><span class="line">    window.Perf = Perf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开<code>console</code>面板，先输入 <code>Perf.start()</code> 执行一些组件操作，引起数据变动，组件更新，然后输入 <code>Perf.stop()</code> 。（建议一次只执行一个操作，好进行分析）</li>
<li>再输入 <code>Perf.printInclusive</code> 查看所有涉及到的组件<code>render</code>，如下图（官方图片）</li>
</ul>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/424.png" alt="img"></p>
<blockquote>
<p>或者输入<code>Perf.printWasted()</code>查看下不需要的的浪费组件<code>render</code></p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/425.png" alt="img"></p>
<p>优化前</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/426.png" alt="img"></p>
<p>优化后</p>
<p><img src="https://poetries1.gitee.io/img-repo/2019/10/427.png" alt="img"></p>
<h2 id="五、其他优化"><a href="#五、其他优化" class="headerlink" title="五、其他优化"></a>五、其他优化</h2><p>1、<strong>前端通用优化。</strong>这类优化在所有前端框架中都存在，重点就在于如何将这些技巧应用在 React 组件中。</p>
<p>2、<strong>减少不必要的组件更新。</strong>这类优化是在组件状态发生变更后，通过减少不必要的组件更新来实现，对应到 React 中就是：<strong>减少渲染的节点 、降低组件渲染的复杂度、充分利用缓存避免重新渲染</strong>（利用缓存可以考虑使用PureComponent、React.memo、hook函数useCallback、useMemo等方法）</p>
<blockquote>
<p>PureComponent 是对<strong>类组件</strong>的 Props 和 State 进行浅比较；React.memo 是对<strong>函数组件</strong>的 Props 进行浅比较</p>
</blockquote>
<p>3、<strong>提交阶段优化。</strong>这类优化的目的是减少提交阶段耗时。</p>
<h3 id="1、组件按需加载"><a href="#1、组件按需加载" class="headerlink" title="1、组件按需加载"></a>1、组件按需加载</h3><p>组件按需加载优化又可以分为：<strong>懒加载、懒渲染、虚拟列表</strong> 三类。</p>
<p><strong>懒加载</strong></p>
<p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块。在这些场景下，可以结合 Code Split 实现。</p>
<p>懒加载的实现主要是通过 Webpack 的动态导入和 <code>React.lazy</code> 方法。注意，实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy, <span class="title class_">Suspense</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对加载失败进行容错处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里处理出错场景<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comp</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;模拟网络出错&quot;</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="title function_">import</span>(<span class="string">&quot;./Component&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginBottom:</span> <span class="attr">20</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&quot;Loading...&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒渲染</strong></p>
<p>懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。</p>
<p>懒渲染的使用场景有：</p>
<ol>
<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>
<li>需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。</li>
</ol>
<p>判断组件是否出现在可视区域内是通过 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/react-visibility-observer">react-visibility-observer</a> 进行监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VisibilityObserver</span>, &#123;</span><br><span class="line">  useVisibilityObserver,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-visibility-observer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">VisibilityObserverChildren</span> = (<span class="params">&#123; callback, children &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isVisible &#125; = <span class="title function_">useVisibilityObserver</span>()</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(isVisible)</span><br><span class="line">  &#125;, [callback, isVisible])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;children&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">LazyRender</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isRendered, setIsRendered] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRendered) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">VisibilityObserver</span> <span class="attr">rootMargin</span>=<span class="string">&#123;</span>&quot;<span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span> <span class="attr">0px</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">VisibilityObserverChildren</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">callback</span>=<span class="string">&#123;isVisible</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            if (isVisible) &#123;</span></span><br><span class="line"><span class="language-xml">              setIsRendered(true)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">VisibilityObserverChildren</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">VisibilityObserver</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;滚动到可视区域才渲染&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 LazyRender 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LazyRender</span></span><br></pre></td></tr></table></figure>

<p><strong>虚拟列表</strong></p>
<p>虚拟列表是懒渲染的一种特殊场景。实现虚拟列表的组件有 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://react-window.now.sh/%23/examples/list/fixed-size">react-window</a> 和 react-virtualized。react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好。新项目中推荐使用 react-window。</p>
<p>使用 react-window 很简单，只需要计算每项的高度即可。如果每项的高度是变化的，可给 itemSize 参数传一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FixedSizeList</span> <span class="keyword">as</span> <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-window&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Row</span> = (<span class="params">&#123; index, style &#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Row &#123;index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">height</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemCount</span>=<span class="string">&#123;1000&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">itemSize</span>=<span class="string">&#123;35&#125;</span> // 每项的高度为 <span class="attr">35</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">width</span>=<span class="string">&#123;300&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;Row&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2、批量更新"><a href="#2、批量更新" class="headerlink" title="2、批量更新"></a>2、批量更新</h3><h3 id="3、利用防抖、节流-避免重复回调"><a href="#3、利用防抖、节流-避免重复回调" class="headerlink" title="3、利用防抖、节流 避免重复回调"></a>3、利用防抖、节流 避免重复回调</h3><h3 id="4、缓存优化"><a href="#4、缓存优化" class="headerlink" title="4、缓存优化"></a>4、缓存优化</h3><p>缓存优化往往是最简单有效的优化方式，在 React 组件中常用 useMemo 缓存上次计算的结果。当 useMemo 的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。</p>
<ol>
<li>React 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://reactjs.org/docs/hooks-faq.html%23how-to-memoize-calculations">How to memoize calculations</a></li>
<li>useMemo 只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 <a href="https://link.zhihu.com/?target=https://link.juejin.cn/?target=https://www.npmjs.com/package/memoizee">memoizee</a>。</li>
</ol>
<h3 id="5、列表项使用-key-属性"><a href="#5、列表项使用-key-属性" class="headerlink" title="5、列表项使用 key 属性"></a>5、列表项使用 key 属性</h3></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/08/React-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/">React设计模式和最佳实践总结（底层总结）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、组件实践"><a href="#一、组件实践" class="headerlink" title="一、组件实践"></a>一、组件实践</h2><h3 id="1-1-设计原则"><a href="#1-1-设计原则" class="headerlink" title="1.1 设计原则"></a>1.1 设计原则</h3><ul>
<li>保持接口小，<code>props</code> 数量要少</li>
<li>根据数据边界来划分组件，充分利用组合</li>
<li>把 state 往上层组件提取，让下层组件只需要实现为纯函数</li>
</ul>
<h3 id="1-2-组件划分"><a href="#1-2-组件划分" class="headerlink" title="1.2 组件划分"></a>1.2 组件划分</h3><blockquote>
<p>任何一个复杂组件都是从简单组件开始的，一开始我们在 render 函数里写的代码不多，但是随着逻辑的复杂，JSX 代码越来越多，于是，就需要拆分函数中的内容</p>
</blockquote>
<ul>
<li>在 React 中，有一个误区，就是把 render 中的代码分拆到多个 renderXXXX 函数中去，比如下面这样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class StopWatch extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const majorClock = this.renderMajorClock();</span><br><span class="line">    const controlButtons = this.renderControlButtons();</span><br><span class="line">    const splitTimes = this.renderSplitTimes();</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">          &#123;majorClock&#125;</span><br><span class="line">          &#123;controlButtons&#125;</span><br><span class="line">          &#123;splitTimes&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderMajorClock() &#123;</span><br><span class="line">     //TODO: 返回数字时钟的JSX</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderControlButtons() &#123;</span><br><span class="line">     //TODO: 返回两个按钮的JSX</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  renderSplitTimes() &#123;</span><br><span class="line">     //TODO: 返回所有计次时间的JSX</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用上面的方法组织代码，当然比写一个巨大的 render 函数要强，但是，实现这么多 renderXXXX 函数并不是一个明智之举，因为这些 renderXXXX 函数访问的是同样的 props 和 state，这样代码依然耦合在了一起。更好的方法，是把这些 renderXXXX 重构成各自独立的 React 组件，像下面这样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class StopWatch extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">          &lt;MajorClock&gt;</span><br><span class="line">          &lt;ControlButtons&gt;</span><br><span class="line">          &lt;SplitTimes&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const MajorClock = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回数字时钟的JSX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const ControlButtons = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回两个按钮的JSX</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">const SplitTimes = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回所有计次时间的JSX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们创造了 <code>MajorClock</code>、<code>ControlButtons</code> 和 <code>SplitTimes</code> 这三个组件，目前，我们并不知道它们是否应该有自己的 <code>state</code>，但是从简单开始，首先假设它们没有自己的 <code>state</code>，定义为函数形式的无状态组件</p>
</blockquote>
<p><strong>组件 props 的设计</strong></p>
<blockquote>
<p>使用 propTypes 来定义组件的 props</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const ControlButtons = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回两个按钮的JSX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ControlButtons.propTypes = &#123;</span><br><span class="line">  activated: PropTypes.bool,</span><br><span class="line">  onStart: PropTypes.func.isRquired,</span><br><span class="line">  onPause: PropTypes.func.isRquired,</span><br><span class="line">  onSplit: PropTypes.func.isRquired,</span><br><span class="line">  onReset: PropTypes.func.isRquired,</span><br><span class="line">  splits: PropTypes.arrayOf(PropTypes.number)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-组件内部实现"><a href="#1-3-组件内部实现" class="headerlink" title="1.3 组件内部实现"></a>1.3 组件内部实现</h3><ul>
<li>尽量每个组件都有自己专属的源代码文件</li>
<li>用解构赋值（destructuring assignment）的方法获取参数 props 的每个属性值</li>
<li>利用属性初始化（property initializer）来定义 state 和成员函数</li>
</ul>
<p><strong>属性初始化方法</strong></p>
<blockquote>
<p>尽量不要在 JSX 中写内联函数（inline function），比如这样写，是很不恰当的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ControlButtons</span><br><span class="line">  activated=&#123;this.state.isStarted&#125;</span><br><span class="line">  onStart=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onPause=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onReset=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">  onSplit=&#123;() =&gt; &#123; /* TODO */&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，按照上面那种写法，也可以完成程序的功能，但是，会带来性能的代价。首先，每一次渲染这段 <code>JSX</code>，都会产生全新的函数对象，这是一种浪费；其次，因为每一次传给 <code>ControlButtons</code> 的都是新的 <code>props</code>，这样 <code>ControlButtons</code> 也无法通过 <code>shouldComponentUpdate</code> 对 <code>props</code> 的检查来避免重复渲染</p>
</blockquote>
<h2 id="二、组件设计模式"><a href="#二、组件设计模式" class="headerlink" title="二、组件设计模式"></a>二、组件设计模式</h2><h3 id="2-1-高阶组件"><a href="#2-1-高阶组件" class="headerlink" title="2.1 高阶组件"></a>2.1 高阶组件</h3><ul>
<li>在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don’t Repeat Yourself)的编码原则，我们肯定想要把这部分共用逻辑提取出来重用</li>
<li>我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强</li>
</ul>
<p><strong>高阶组件的基本形式</strong></p>
<blockquote>
<p>“高阶组件”名为“组件”，其实并不是一个组件，而是一个函数，只不过这个函数比较特殊，它接受至少一个 React 组件为参数，并且能够返回一个全新的 React 组件作为结果，当然，这个新产生的 React 组件是对作为参数的组件的包装，所以，有机会赋予新组件一些增强的“神力”</p>
</blockquote>
<p>一个最简单的高阶组件是这样的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const withDoNothing = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的函数 withDoNothing 就是一个高阶组件，作为一项业界通用的代码规范，高阶组件的命名一般都带 with 前缀，命名中后面的部分代表这个高阶组件的功能</li>
</ul>
<blockquote>
<p>就如同 withDoNothing 这个名字所说的一样，这个高阶组件什么都没做，但是从中可以看出高阶组件的基本代码套路</p>
</blockquote>
<ul>
<li>高阶组件不能去修改作为参数的组件，高阶组件必须是一个纯函数，不应该有任何副作用。</li>
<li>高阶组件返回的结果必须是一个新的 React 组件，这个新的组件的 JSX 部分肯定会包含作为参数的组件</li>
<li>高阶组件一般需要把传给自己的 props 转手传递给作为参数的组件</li>
</ul>
<p><strong>用高阶组件抽取共同逻辑</strong></p>
<blockquote>
<p>接下来，我们对 withDoNothing 进行一些改进，让它实现“只有在登录时才显示”这个功能</p>
</blockquote>
<p>假设我们已经有一个函数 getUserId 能够从 cookies 中读取登录用户的 ID，如果用户未登录，这个 getUserId 就返回空，那么“退出登录按钮“就需要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const LogoutButton = () =&gt; &#123;</span><br><span class="line">  if (getUserId()) &#123;</span><br><span class="line">    return ...; // 显示”退出登录“的JSX</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，购物车的代码就是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ShoppintCart = () =&gt; &#123;</span><br><span class="line">  if (getUserId()) &#123;</span><br><span class="line">    return ...; // 显示”购物车“的JSX</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个组件明显有重复的代码，我们可以把重复代码抽取出来，形成 withLogin 这个高阶组件，代码如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const withLogin = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    if (getUserId()) &#123;</span><br><span class="line">      return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如此一来，我们就只需要这样定义 LogoutButton 和 ShoppintCart：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const LogoutButton = withLogin((props) =&gt; &#123;</span><br><span class="line">  return ...; // 显示”退出登录“的JSX</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const ShoppingCart = withLogin(() =&gt; &#123;</span><br><span class="line">  return ...; // 显示”购物车“的JSX</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们避免了重复代码，以后如果要修改对用户是否登录的判断逻辑，也只需要修改 <code>withLogin</code>，而不用修改每个 React 组件</p>
</blockquote>
<p><strong>高阶组件的高级用法</strong></p>
<ul>
<li>高阶组件只需要返回一个 React 组件即可，没人规定高阶组件只能接受一个 React 组件作为参数，完全可以传入多个 React 组件给高阶组件</li>
<li>比如，我们可以改进上面的 withLogin，让它接受两个 React 组件，根据用户是否登录选择渲染合适的组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const withLoginAndLogout = (ComponentForLogin, ComponentForLogout) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    if (getUserId()) &#123;</span><br><span class="line">      return &lt;ComponentForLogin &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &lt;ComponentForLogout&#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了上面的 withLoginAndLogout，就可以产生根据用户登录状态显示不同的内容</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const TopButtons = withLoginAndLogout(</span><br><span class="line">  LogoutButton,</span><br><span class="line">  LoginButton</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>链式调用高阶组件</strong></p>
<ul>
<li>高阶组件最巧妙的一点，是可以链式调用。</li>
<li>假设，你有三个高阶组件分别是 withOne、withTwo 和 withThree，那么，如果要赋予一个组件 X 某个高阶组件的超能力，那么，你要做的就是挨个使用高阶组件包装，代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const X1 = withOne(X);</span><br><span class="line">const X2 = withTwo(X1);</span><br><span class="line">const X3 = withThree(X2);</span><br><span class="line">const SuperX = X3; //最终的SuperX具备三个高阶组件的超能力</span><br></pre></td></tr></table></figure>

<p>很自然，我们可以避免使用中间变量 X1 和 X2，直接连续调用高阶组件，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const SuperX = withThree(withTwo(withOne(X)));</span><br></pre></td></tr></table></figure>

<p>对于 X 而言，它被高阶组件包装了，至于被一个高阶组件包装，还是被 N 个高阶组件包装，没有什么差别。而高阶组件本身就是一个纯函数，纯函数是可以组合使用的，所以，我们其实可以把多个高阶组件组合为一个高阶组件，然后用这一个高阶组件去包装X，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const hoc = compose(withThree, withTwo, withOne);</span><br><span class="line">const SuperX = hoc(X);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中使用的 compose，是函数式编程中很基础的一种方法，作用就是把多个函数组合为一个函数，在很多开源的代码库中都可以看到，下面是一个参考实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line">  if (funcs.length === 0) &#123;</span><br><span class="line">    return arg =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 1) &#123;</span><br><span class="line">    return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>React 组件可以当做积木一样组合使用，现在有了 compose，我们就可以把高阶组件也当做积木一样组合，进一步重用代码。</li>
<li>假如一个应用中多个组件都需要同样的多个高阶组件包装，那就可以用 compose 组合这些高阶组件为一个高阶组件，这样在使用多个高阶组件的地方实际上就只需要使用一个高阶组件了</li>
</ul>
<p><strong>不要滥用高阶组件</strong></p>
<blockquote>
<p>高阶组件虽然可以用一种可重用的方式扩充现有 React 组件的功能，但高阶组件并不是绝对完美的</p>
</blockquote>
<p>首先，高阶组件不得不处理 displayName，不然 debug 会很痛苦。当 React 渲染出错的时候，靠组件的 displayName 静态属性来判断出错的组件类，而高阶组件总是创造一个新的 React 组件类，所以，每个高阶组件都需要处理一下 displayName</p>
<p>如果要做一个最简单的什么增强功能都没有的高阶组件，也必须要写下面这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const withExample = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    return &lt;Component &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  NewComponent.displayName = `withExample($&#123;Component.displayName || Component.name || &#x27;Component&#x27;&#125;)`;</span><br><span class="line">  </span><br><span class="line">  return NewCompoennt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个高阶组件都这么写，就会非常的麻烦</p>
<p>对于 React 生命周期函数，高阶组件不用怎么特殊处理，但是，如果内层组件包含定制的静态函数，这些静态函数的调用在 React 生命周期之外，那么高阶组件就必须要在新产生的组件中增加这些静态函数的支持，这更加麻烦</p>
<blockquote>
<p>其次，高阶组件支持嵌套调用，这是它的优势。但是如果真的一大长串高阶组件被应用的话，当组件出错，你看到的会是一个超深的 stack trace，十分痛苦</p>
</blockquote>
<blockquote>
<p>最后，使用高阶组件，一定要非常小心，要避免重复产生 React 组件，比如，下面的代码是有问题的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Example = () =&gt; &#123;</span><br><span class="line">  const EnhancedFoo = withExample(Foo);</span><br><span class="line">  return &lt;EnhancedFoo /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像上面这样写，每一次渲染 Example，都会用高阶组件产生一个新的组件，虽然都叫做 EnhancedFoo，但是对 React 来说是一个全新的东西，在重新渲染的时候不会重用之前的虚拟 DOM，会造成极大的浪费</p>
<p>正确的写法是下面这样，自始至终只有一个 EnhancedFoo 组件类被创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedFoo = withExample(Foo);</span><br><span class="line"></span><br><span class="line">const Example = () =&gt; &#123;</span><br><span class="line">  return &lt;EnhancedFoo /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="render-props-模式"><a href="#render-props-模式" class="headerlink" title="render props 模式"></a>render props 模式</h3><blockquote>
<p>所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props</p>
</blockquote>
<p>一个最简单的 render props 组件 RenderAll，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const RenderAll = (props) =&gt; &#123;</span><br><span class="line">  return(</span><br><span class="line">     &lt;React.Fragment&gt;</span><br><span class="line">     	&#123;props.children(props)&#125;</span><br><span class="line">     &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 <code>RenderAll</code> 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 <code>props</code>，然后把返回结果渲染出来，除此之外什么事情都没有做</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;RenderAll&gt;</span><br><span class="line">&#123;() =&gt; &lt;h1&gt;hello world&lt;/h1&gt;&#125;</span><br><span class="line">&lt;/RenderAll&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 <code>hello world</code>，这就是上面使用 RenderAll 渲染出来的结果。</p>
<p>当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。</p>
<p><strong>传递 props</strong></p>
<blockquote>
<p>和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props</p>
</blockquote>
<p>下面是实现 <code>render props</code> 的 <code>Login</code> 组件，可以看到，<code>render props</code> 和高阶组件的第一个区别，就是 <code>render props</code> 是真正的 <code>React</code> 组件，而不是一个返回 React 组件的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const Login = (props) =&gt; &#123;</span><br><span class="line">  const userName = getUserName();</span><br><span class="line"></span><br><span class="line">  if (userName) &#123;</span><br><span class="line">    const allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;props.children(allProps)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。</p>
<p>当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。</p>
<p>一个使用上面 Login 的 JSX 代码示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Login&gt;</span><br><span class="line">&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;</span><br><span class="line">&lt;/Login&gt;</span><br></pre></td></tr></table></figure>

<p><strong>不局限于 children</strong></p>
<p>实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。</p>
<p>我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Auth= (props) =&gt; &#123;</span><br><span class="line">  const userName = getUserName();</span><br><span class="line"></span><br><span class="line">  if (userName) &#123;</span><br><span class="line">    const allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;props.login(allProps)&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &#123;props.nologin(props)&#125;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Auth</span><br><span class="line">    login=&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125;</span><br><span class="line">    nologin=&#123;() =&gt; &lt;h1&gt;Please login&lt;/h1&gt;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>依赖注入</strong></p>
<ul>
<li>render props 其实就是 React 世界中的“依赖注入”</li>
<li>所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A</li>
<li>在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C</li>
</ul>
<p><strong>render props 和高阶组件的比较</strong></p>
<ul>
<li>首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数</li>
<li>render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const withLogin = (Component) =&gt; &#123;</span><br><span class="line">  const NewComponent = (props) =&gt; &#123;</span><br><span class="line">    const userName= getUserName();</span><br><span class="line">    if (userName) &#123;</span><br><span class="line">      return &lt;Component &#123;...props&#125; userName=&#123;userName&#125;/&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NewComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事</p>
<p>对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Login&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    (props) =&gt; &#123;</span><br><span class="line">      const &#123;userName&#125; = props;</span><br><span class="line">      return &lt;TheComponent &#123;...props&#125; name=&#123;userName&#125; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/Login&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。<br>这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例</p>
</blockquote>
<h3 id="2-2-提供者模式"><a href="#2-2-提供者模式" class="headerlink" title="2.2 提供者模式"></a>2.2 提供者模式</h3><p><strong>问题场景</strong></p>
<blockquote>
<p>在 React 中，props 是组件之间通讯的主要手段，但是，有一种场景单纯靠 props 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图图</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/30/16627df7e8c08232" alt="img"></p>
<p>在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。</p>
<p>其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。</p>
<p>可见，对于跨级的信息传递，我们需要一个更好的方法。</p>
<p>在 React 中，解决这个问题应用的就是“提供者模式”</p>
<p><strong>提供者模式</strong></p>
<ul>
<li>虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个叫“提供者”（Provider），另一个叫“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者</li>
<li>既然名为“提供者”，它可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。</li>
<li>避免 <code>props</code> 逐级传递，即是提供者的用途。</li>
</ul>
<p><strong>如何实现提供者模式</strong></p>
<ul>
<li>实现提供者模式，需要 React 的 Context 功能，可以说，提供者模式只不过是让 Context 功能更好用一些而已</li>
<li>所谓 Context 功能，就是能够创造一个“上下文”，在这个上下文笼罩之下的所有组件都可以访问同样的数据</li>
<li>在 React v16.3.0 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用，因为对应的 API 他们并不满意，觉得迟早要废弃掉。即使如此，依然有很多库和应用使用 Context 功能，可见对这个需求的呼声有多大</li>
<li>当 React 发布 v16.3.0 时，终于提供了“正式版本”的 Context 功能 API，和之前的有很大不同，</li>
<li>提供者模式的一个典型用例就是实现“样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。</li>
</ul>
<blockquote>
<p>为了方便比对，这里会介绍提供者模式用不同 Context API 的实现方法。不过，你如果完全不在意老版本 React 如何实现的，可以略过下面一段。</p>
</blockquote>
<p><strong>React v16.3.0 之前的提供者模式</strong></p>
<blockquote>
<p>在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做两个特殊处理</p>
</blockquote>
<ul>
<li>需要实现 getChildContext 方法，用于返回“上下文”的数据</li>
<li>需要定义 childContextTypes 属性，声明“上下文”的结构。</li>
</ul>
<p>下面就是一个实现“提供者”的例子，组件名为 ThemeProvider：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ThemeProvider extends React.Component &#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      theme: this.props.value</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThemeProvider.childContextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，getChildContext 只是简单返回名为 value 的 props 值，但是，因为 getChildContext 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。</p>
<p>对于 ThemeProvider，我们创造了一个上下文，这个上下文就是一个对象，结构是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  theme: &#123;</span><br><span class="line">    //一个对象</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来做两个消费（也就是使用）这个“上下文”的组件，第一个是 Subject，代表标题；第二个是 Paragraph，代表章节。</p>
<p>我们把 Subject 实现为一个类，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Subject extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;mainColor&#125; = this.context.theme;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1 style=&#123;&#123;color: mainColor&#125;&#125;&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject.contextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Subject 的 render 函数中，可以通过 this.context 访问到“上下文”数据，因为 ThemeProvider 提供的“上下文”包含 theme 字段，所以可以直接访问 this.context.theme。</p>
<p>千万不要忘了 Subject 必须增加 contextTypes 属性，必须和 ThemeProvider 的 childContextTypes 属性一致，不然，this.context 就不会得到任何值。</p>
<p>读者可能会问了，为什么这么麻烦呢？为什么要求“提供者”用 childContextTypes 定义一次上下文结构，又要求“消费者”再用 contextTypes 再重复定义一次呢？这不是很浪费吗？</p>
<p>React 这么要求，是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。</p>
<p>不过，实话实说，这样的 API 设计的确麻烦了一点，难怪 React 官方在最初就不建议使用。</p>
<p>上面的 Subject 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，我们用纯函数的方式实现另一个消费者 Paragraph，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Paragraph = (props, context) =&gt; &#123;</span><br><span class="line">  const &#123;textColor&#125; = context.theme;</span><br><span class="line">  return (</span><br><span class="line">    &lt;p style=&#123;&#123;color: textColor&#125;&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Paragraph.contextTypes = &#123;</span><br><span class="line">  theme: PropTypes.object</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，因为 Paragraph 是一个函数形式，所以不可能访问 this.context，但是函数的第二个参数其实就是 context。</p>
<p>当然，也不要忘了设定 Paragraph 的 contextTypes，不然参数 context 也不会是上下文。</p>
<p>最后，我们看如何结合”提供者“和”消费者“。</p>
<p>我们做一个组件来使用 Subject 和 Paragraph，这个组件不需要帮助传递任何 props，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Page = () =&gt; (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Subject&gt;这是标题&lt;/Subject&gt;</span><br><span class="line">    &lt;Paragraph&gt;</span><br><span class="line">      这是正文</span><br><span class="line">    &lt;/Paragraph&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的组件 Page 使用了 Subject 和 Paragraph，现在我们想要定制样式主题，只需要在 Page 或者任何需要应用这个主题的组件外面包上 ThemeProvider，对应的 JSX 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;</span><br><span class="line">  &lt;Page /&gt;</span><br><span class="line">&lt;/ThemeProvider&gt;</span><br></pre></td></tr></table></figure>

<p>当我们需要改变一个样式主题的时候，改变传给 ThemeProvider的 value 值就搞定了</p>
<p><strong>React v16.3.0 之后的提供者模式</strong></p>
<ul>
<li>到了 React v16.3.0 的时候，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。</li>
<li>还是上面的样式主题的例子，首先，要用新提供的 createContext 函数创造一个“上下文”对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ThemeContext = React.createContext();</span><br></pre></td></tr></table></figure>

<p>这个“上下文”对象 ThemeContext 有两个属性，分别就是——对，你没猜错——Provider 和 Consumer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ThemeProvider = ThemeContext.Provider;</span><br><span class="line">const ThemeConsumer = ThemeContext.Consumer;</span><br></pre></td></tr></table></figure>

<p>创造“提供者”极大简化了，都不需要我们创造一个 React 组件类。</p>
<p>使用“消费者”也同样简单，而且应用了上一节我们介绍的 render props 模式，比如，Subject 的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Subject extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ThemeConsumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (theme) =&gt; (</span><br><span class="line">            &lt;h1 style=&#123;&#123;color: theme.mainColor&#125;&#125;&gt;</span><br><span class="line">              &#123;this.props.children&#125;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/ThemeConsumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 ThemeConsumer 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。</p>
<p>在新的 API 里，不需要设定组件的 childContextTypes 或者 contextTypes 属性，这省了不少事。</p>
<p>可以注意到，Subject 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 Paragraph，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Paragraph = (props, context) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeConsumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        (theme) =&gt; (</span><br><span class="line">          &lt;p style=&#123;&#123;color: theme.textColor&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ThemeConsumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现 Page 的方式并没有变化，而应用 ThemeProvider 的代码和之前也完全一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeProvider value=&#123;&#123;mainColor: &#x27;green&#x27;, textColor: &#x27;red&#x27;&#125;&#125; &gt;</span><br><span class="line">  &lt;Page /&gt;</span><br><span class="line">&lt;/ThemeProvider&gt;</span><br></pre></td></tr></table></figure>

<p><strong>两种提供者模式实现方式的比较</strong></p>
<ul>
<li>通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但是，也并不是十全十美。</li>
<li>在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。</li>
<li>在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 ThemeContext)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，那么，这个 ThemeContext 对象放在哪个代码文件中呢？</li>
<li>最好是放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。</li>
<li>为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。</li>
<li>不管怎么说，新版本的 Context API 才是未来，在 React v17 中，可能就会删除对老版 Context API 的支持，所以，现在大家都应该使用第二种实现方式。</li>
</ul>
<h3 id="2-3-组合组件"><a href="#2-3-组合组件" class="headerlink" title="2.3 组合组件"></a>2.3 组合组件</h3><p><strong>问题描述</strong></p>
<p>为了让问题更加具体，我们来解决一个实例。</p>
<p>很多界面都有 Tab 这样的元件，我们需要一个 Tabs 组件和 TabItem 组件，Tabs 是容器，TabItem 是一个一个单独的 Tab，因为一个时刻只有一个 TabItem 被选中，很自然希望被选中的 TabItem 样式会和其他 TabItem 不同。</p>
<p>这并不是一个很难的功能，首先我们想到的就是，用 Tabs 中一个 state 记录当前被选中的 Tabitem 序号，然后根据这个 state 传递 props 给 TabItem，当然，还要传递一个 onClick 事件进去，捕获点击选择事件。</p>
<p>按照这样的设计，Tabs 中如果要显示 One、Two、Three 三个 TabItem，JSX 代码大致这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabItem active=&#123;true&#125; onClick=&#123;this.onClick&#125;&gt;One&lt;/TabItem&gt;</span><br><span class="line">&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Two&lt;/TabItem&gt;</span><br><span class="line">&lt;TabItem active=&#123;false&#125; onClick=&#123;this.onClick&#125;&gt;Three&lt;/TabItem&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的 TabItem 组件接受 active 这个 props，如果 true 代表当前是选中状态，当然可以工作，但是，也存在大问题</p>
</blockquote>
<ul>
<li>每次使用 TabItem 都要传递一堆 props，好麻烦；</li>
<li>每增加一个新的 TabItem，都要增加对应的 props，更麻烦；</li>
<li>如果要增加 TabItem，就要去修改 Tabs 的 JSX 代码，超麻烦。</li>
</ul>
<p>我们不想要这么麻烦，理想情况下，我们希望可以随意增加减少 TabItem 实例，不用传递一堆 props，也不用去修改 Tabs 的代码，最好代码就这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tabs&gt;</span><br><span class="line">  &lt;TabItem&gt;One&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Two&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Three&lt;/TabItem&gt;</span><br><span class="line">&lt;/Tabs&gt;</span><br></pre></td></tr></table></figure>

<p>如果能像上面一样写代码，那就达到目的了。</p>
<blockquote>
<p>像上面这样，Tabs 和 TabItem 不通过表面的 props 传递也能心有灵犀，二者之间有某种神秘的“组合”，就是我们所说的“组合组件”。</p>
</blockquote>
<p><strong>实现方式</strong></p>
<p>上面我们说过，利用 Context API，可以实现组合组件，但是那样 TabItem 需要应用 render props，至于如何实现，读者可以参照上一节的介绍自己尝试。</p>
<p>在这里，我们用一种更巧妙的方式来实现组合组件，可以避免 TabItem 的复杂化。</p>
<p>我们先写出 TabItem 的代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const TabItem = (props) =&gt; &#123;</span><br><span class="line">  const &#123;active, onClick&#125; = props;</span><br><span class="line">  const tabStyle = &#123;</span><br><span class="line">    &#x27;max-width&#x27;: &#x27;150px&#x27;,</span><br><span class="line">    color: active ? &#x27;red&#x27; : &#x27;green&#x27;,</span><br><span class="line">    border: active ? &#x27;1px red solid&#x27; : &#x27;0px&#x27;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1 style=&#123;tabStyle&#125; onClick=&#123;onClick&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TabItem 有两个重要的 props：active 代表自己是否被激活，onClick 是自己被点击时应该调用的回调函数，这就足够了。TabItem 所做的就是根据这两个 props 渲染出 props.children，没有任何复杂逻辑，是一个活脱脱的“傻瓜组件”，所以，用一个纯函数实现就可以了。</p>
<p>接下来要做的，就看 Tabs 如何把 active 和 onClick 传递给 TabItem。</p>
<p>我们再来看一下使用组合组件的 JSX 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tabs&gt;</span><br><span class="line">  &lt;TabItem&gt;One&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Two&lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem&gt;Three&lt;/TabItem&gt;</span><br><span class="line">&lt;/Tabs&gt;</span><br></pre></td></tr></table></figure>

<p>没有 props 的传递啊，怎么悄无声息地把 active 和 onClick 传递给 TabItem 呢？</p>
<p>Tabs 虽然可以访问到作为 props 的 children，但是到手的 children 已经是创造好的元素，而且是不可改变的，Tabs 是不可能把创造好的元素再强塞给 children 的。</p>
<p>怎么办？</p>
<p>办法还是有的，如果 Tabs 并不去渲染 children，而是把 children 拷贝一份，就有机会去篡改这份拷贝，最后渲染这份拷贝就好了。</p>
<p>我们来看 Tabs 的实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Tabs extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    activeIndex:  0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const newChildren = React.Children.map(this.props.children, (child, index) =&gt; &#123;</span><br><span class="line">      if (child.type) &#123;</span><br><span class="line">        return React.cloneElement(child, &#123;</span><br><span class="line">          active: this.state.activeIndex === index,</span><br><span class="line">          onClick: () =&gt; this.setState(&#123;activeIndex: index&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &#123;newChildren&#125;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 render 函数中，我们用了 React 中不常用的两个 API：</p>
<ul>
<li><code>React.Children.map</code></li>
<li><code>React.cloneElement</code></li>
</ul>
<p>使用 React.Children.map，可以遍历 children 中所有的元素，因为 children 可能是一个数组嘛。</p>
<p>使用 React.cloneElement 可以复制某个元素。这个函数第一个参数就是被复制的元素，第二个参数可以增加新产生元素的 props，我们就是利用这个机会，把 active 和 onClick 添加了进去。</p>
<p>这两个 API 双剑合璧，就能实现不通过表面的 props 传递，完成两个组件的“组合”</p>
<p><strong>实际应用</strong></p>
<ul>
<li>从上面的代码可以看出来，对于组合组件这种实现方式，TabItem 非常简化；Tabs 稍微麻烦了一点，但是好处就是把复杂度都封装起来了，从使用者角度，连 props 都看不见。</li>
<li>所以，应用组合组件的往往是共享组件库，把一些常用的功能封装在组件里，让应用层直接用就行。在 antd 和 bootstrap 这样的共享库中，都使用了组合组件这种模式。</li>
<li>如果你的某两个组件并不需要重用，那么就要谨慎使用组合组件模式，毕竟这让代码复杂了一些。</li>
</ul>
<h2 id="三、React-单元测试"><a href="#三、React-单元测试" class="headerlink" title="三、React 单元测试"></a>三、React 单元测试</h2><h3 id="3-1-测试的目的"><a href="#3-1-测试的目的" class="headerlink" title="3.1 测试的目的"></a>3.1 测试的目的</h3><p>测试对于软件开发非常重要，简单来说，测试就是尽力发现软件中的缺陷（俗称 bug），当我们发现不了更多的 bug 时，说明这个软件质量可以接受了。</p>
<p>然而，没有 bug 的软件我还没见过呢。</p>
<p>在互联网时代，我们更是不可能等到所有 bug 都修复了才上线，那样黄花菜都凉了，稍微有一些工作经验的人都会有这样的体会。</p>
<p>所以，事实上，测试是尽力发现软件中的 bug。当我们发现 bug 数量和严重程度呈稳定的下降趋势，直到低于一个门槛（无须降低为 0，只需要降低到可接受的程度），没有更多更严重的 bug 出现，就说明这个软件的质量可以接受，可以上线了。</p>
<p>这样当然要比达到“零 bug 软件”要容易多了，但是，不要因此以为这就是一件没有困难的任务。为了让 bug 的数量和严重程度足够低，我们开发者必须严格要求自己，只有保证我们写的每一小块代码都经受住测试的考验，这些小块代码集合在一起的时候才可能（只是有可能）不会出很多 bug，如果我们写的小块代码质量都无法保证，那大项目的代码根本无法保证</p>
<h2 id="四、单元测试"><a href="#四、单元测试" class="headerlink" title="四、单元测试"></a>四、单元测试</h2><p><strong>Jest</strong></p>
<p>在 JavaScript 的世界里，单元测试的框架很多，品牌最老名气最响的是 Mocha ，不过，不要纠结于名气，请使用 Jest 。你不会后悔的，接下来我告诉你为什么。</p>
<p>我们先假设，作为开发者，你是在团队中工作。所谓团队，就是有很多人一起工作，而且随着业务和团队的发展，人会越来越多，潜台词就是——不确定因素越来越多。</p>
<p>人和人之间交流会出现偏差，人的水平有高低之分，人也会犯错，总之，你不能指望所有人都把事情做得尽善尽美。</p>
<p>具体到单元测试这件事上来，“测试驱动”是开发喊了这么多年，为什么真正做到这一点的团队依然不多呢？因为，当团队变大之后，很多问题也就出现了</p>
<p>1、单元测试用例庞大，执行时间过长。</p>
<p>想象一下，一个代码库里假设有一千个单元测试用例，即使每个单元测试用例平均只需要 10 毫秒，那总时间也就需要 10 秒钟。好，假设代码库进一步扩大，有了一万个单元测试用例，那就跑一遍就需要 100 秒，已经超过了一分钟。这还只是保守估计，实际上单元测试用例的运行时间只会比这长。开发者如果每次修改都需要等待这么漫长的单元测试运行时间，肯定会三心二意上网去看其他东西。</p>
<p>2、 单元测试用例之间相互影响。</p>
<p>你可能也有这样的体验，代码库中的单元测试突然失败了，但是你修改的代码根本不会取影响失败的那个单元测试用例，怎么回事？这往往是因为某个成员以前的代码写得不好，影响了一个全局变量。当然，谁都知道单元测试应该在 setup 时创建环境，在 teardown 时恢复环境，可是，总会有人有马虎大意的情况，这时候你怎么办？要么你只好去修复一个本不是你改坏的代码，要么你干脆删掉那段不可靠的单元测试代码，不管怎样，这都会打击你支持“测试驱动开发”的决心。</p>
<p>Jest 较好地解决了上面说的问题，因为 Jest 最重要的一个特性，就是支持并行执行</p>
<p>Mocha 之类老牌单元测试框架，把所有的单元测试都放在一个环境中执行，这就使所有单元测试访问的是同样一个全局变量空间，所以只要测试代码没写好，就会互相影响。而且，为了保证执行正常，所有的单元测试必须一个接一个地执行，这是体系架构决定的，没有办法。</p>
<p>Jest 不同，Jest 为每一个单元测试文件创造一个独立的运行环境，换句话说，Jest 会启动一个进程执行一个单元测试文件，运行结束之后，就把这个执行进程废弃了，这个单元测试文件即使写得比较差，把全局变量污染得一团糟，也不会影响其他单元测试文件，因为其他单元测试文件是用另一个进程来执行</p>
<p>更妙的是，因为每个单元测试文件之间再无纠葛，Jest 可以启动多个进程同时运行不同的文件，这样就充分利用了电脑的多 CPU 多核，单进程 100 秒才完成的测试执行过程，8 核只需要 12.5 秒，速度快了很多。</p>
<p>Jest 还有很多其他友好的特性，大家可以自己去发掘，这里废话不多说，只想安利各位，测试 React 或者 JavaScript 代码，用 Jest！</p>
<p>使用 create-react-app 产生的项目自带 Jest 作为测试框架，不奇怪，因为 Jest 和 React 一样都是出自 Facebook。</p>
<p>运行下面的命令，就可以进入交互式的”测试驱动开发“模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure>

<p><strong>Enzyme</strong></p>
<p>虽然最好的 React 测试框架出自 Facebook 家，最受欢迎的 React 测试工具库却出自 Airbnb，这个工具库叫做 Enzyme。Enzyme 这个单词的含义是“酶”，至于命名原因已经无法考据，可能寓意着快速分解。</p>
<p>不过因为 Enzyme 不是 Facebook 家出品，所以使用 Enzyme 还真稍微有些麻烦——在 create-react-app 产生的应用中并不包含 Enzyme，需要我们自己来添加。</p>
<p>在项目目录下，通过下面的命令来安装 enzyme</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure>

<p>可以注意到，我们不光要安装 enzyme，还要安装 enzyme-adapter-react-16，这个库是用来作为适配器的。因为不同 React 版本有各自特点，所用的适配器也会不同，我们的项目中使用的是 16.4 之后的版本，所以用 enzyme-adapter-react-16；如果用 16.3 版本，需要用 enzyme-adapter-react-16.3；如果用 16.2 版本，需要用 enzyme-adapter-react-16.2；如果用更老的版本 15.5，需要用 enzyme-adapter-react-15。具体各个 React 版本对应什么样的 Adapter，请参考 enzyme官方文档。</p>
<p>现在，可以在测试代码中使用 enzyme 了。我们以之前秒表应用中的 ControlButtons 组件为例，来说明如何做单元测试。</p>
<p>我们创造一个 ControlButtons.test.js，来容纳对应的测试用例，因为所有后缀为 .test.js 的文件都会被 Jest 认作是测试用例文件。</p>
<p>在代码中，需要使用 Adapter，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;configure&#125; from &#x27;enzyme&#x27;;</span><br><span class="line">import Adapter from &#x27;enzyme-adapter-react-16&#x27;;</span><br><span class="line">configure(&#123;adapter: new Adapter()&#125;);</span><br></pre></td></tr></table></figure>

<p>我们对 ControlButtons 组件的测试，就是要渲染它一次，看看渲染结果如何，enzyme 就能帮助我们做这件事。</p>
<p>比如，我们想要保证渲染出来的内容必须包含两个按钮，其中一个按钮的 class 名是 left-btn，另一个是 right-btn，那么我们就需要下面的单元测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;shallow&#125; from &#x27;enzyme&#x27;;</span><br><span class="line"></span><br><span class="line">it(&#x27;renders without crashing&#x27;, () =&gt; &#123;</span><br><span class="line">  const wrapper = shallow(&lt;ControlButtons /&gt;);</span><br><span class="line">  expect(wrapper.find(&#x27;.left-btn&#x27;)).toHaveLength(1);</span><br><span class="line">  expect(wrapper.find(&#x27;.right-btn&#x27;)).toHaveLength(1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里我们使用了 shallow，其实也可以使用 mount。</p>
<p>shallow 和 mount 的区别，就是 shallow 只会渲染被测试的 React 组件这一层，不会渲染子组件；而 mount 则是完整地渲染 React 组件包括其所有子组件，包括触发 componentDidMount 生命周期函数。</p>
<p>原则上，能用 shallow 就尽量用 shallow，首先是为了测试性能考虑，其次是可以减少组件之间的影响，比如，一个组件 Foo 有子组件 Bar，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; ()</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &#123;/* other logic */</span><br><span class="line">       &lt;Bar /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果用 mount 去渲染 Foo，会连带 Bar 一起完全渲染，如果 Bar 出了什么毛病，那 Foo 的单元测试也过不了；如果用 shallow，只知道 Bar 曾经被用，即使 Bar 哪里出了问题，也不影响 Foo 的单元测试。</p>
<p>这并不是说我们就不管 Bar，Bar 的质量会由它自己的单元测试来检验，这就引出下一个话题——代码覆盖率。</p>
<p><strong>代码覆盖率</strong></p>
<p>你不能给自己的程序随便写几个单元测试，就说自己的代码已经测试好了，就像上面我只给 ControlButtons 组件写了一个测试用例，我并不能说整个秒表应用已经通过了测试。</p>
<p>你的代码测试覆盖率只有达到一定程度，才好说自己的代码已经被测试了。</p>
<p>剩下来就是一个纠结的问题：代码测试的覆盖率应该达到多少才算够？</p>
<p>以我个人的经验，代码覆盖率必须达到 100%，也就是说，一个应用不光所有的单元测试都要通过，而且所有单元测试都必须覆盖到代码 100% 的角落。</p>
<p>如果对覆盖率的要求低于 100%，时间一长，质量必定会越来越下滑。</p>
<p>遇到一个不好测试的代码，开发者倾向于不去考虑如何重构代码提高可测试性，而是直接忽略这部分代码不去测试，反正不要求 100% 嘛；遇到工期比较紧的时候，甚至会进一步降低代码覆盖率要求，用牺牲质量来加快开发速度，反正不要求 100% 嘛。</p>
<p>所以，如果你真的对代码质量认真负责的话，请坚守 100% 代码覆盖率的底线！</p>
<p>在 create-react-app 创造的应用中，已经自带了代码覆盖率的支持，运行下面的命令，不光会运行所有单元测试，也会得到覆盖率汇报</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test -- --coverage</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码覆盖率包含四个方面：</p>
</blockquote>
<ul>
<li>语句覆盖率</li>
<li>逻辑分支覆盖率</li>
<li>函数覆盖率</li>
<li>代码行覆盖率</li>
</ul>
<p>只有四个方面都是 100%，才算真的 100%。</p>
<h2 id="五、React-状态管理"><a href="#五、React-状态管理" class="headerlink" title="五、React 状态管理"></a>五、React 状态管理</h2><h3 id="5-1-组件状态"><a href="#5-1-组件状态" class="headerlink" title="5.1 组件状态"></a>5.1 组件状态</h3><p>React 其实就是这样一个公式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>f 的参数 data，除了 props，就是 state。props 是组件外传递进来的数据，state 代表的就是 React 组件的内部状</p>
</blockquote>
<p><strong>为什么要了解 React 组件自身状态管理</strong></p>
<ul>
<li>因为 React 组件自身的状态管理是基础，其他第三方工具都是在这个基础上构筑的，连基础都不了解，无法真正理解第三方工具</li>
<li>对于很多应用场景，React 组件自身的状态管理就足够解决问题，犯不上动用 Redux 和 MobX 这样的大杀器，简单问题简单处理，可以让代码更容易维护</li>
</ul>
<p><strong>组件自身状态 state</strong></p>
<p>什么数据放在 state 中</p>
<p>对于 React 组件而言，数据分为两种</p>
<ul>
<li><code>props</code></li>
<li><code>state</code></li>
</ul>
<p>二者的区别显而易见，简单说就是，props 是外部传给组件的数据，而 state 是组件自己维护的数据，对外部是不可见的。</p>
<p>所以，判断某个数据以 props 方式存在，还是以 state 方式存在，并不难，只需要判断这个状态是否是组件内部状态。</p>
<p>一个经常被问到的问题，就是为什么不把组件的数据直接存放在组件类的成员变量中？比如像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component &#123;</span><br><span class="line">  foo = &#x27;foo&#x27;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;&#123;this.foo&#125;&lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>像上面，数据存在 this.foo 中，而不是存在 this.state.foo 中，当这个组件渲染的时候，当然 this.foo 的值也就被渲染出来了，问题是，更新 this.foo 并不会引发组件的重新渲染，这很可能不是我们想要的。</p>
</blockquote>
<p>所以，判断一个数据应该放在哪里，用下面的原则</p>
<ul>
<li>如果数据由外部传入，放在 props 中</li>
<li>如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 state 中；不是，放在成员变量中</li>
</ul>
<p><strong>修改 state 的正确方式</strong></p>
<p>组件自身的状态可以通过 this.state 读到，this.state 本身就是一个对象，但是修改状态不应该通过直接修改 this.state 对象来完成。因为，我们修改 state，当然不只是想修改这个对象的值，而是想引发 React 组件的重新渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state.foo = &#x27;bar&#x27;; //错误的方式</span><br><span class="line"></span><br><span class="line">this.setState(&#123;foo:&#x27;bar&#x27;&#125;); //正确的方式</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，如果只是修改 this.state，那改了也就只是改了这个对象，其他的什么都不会发生；如果使用 setState 函数，那不光修改 state，还能引发组件的重新渲染，在重新渲染中就会使用修改后的 state，这也就是达到根据 state 改变公式左侧 UI 的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UI = f(state)</span><br></pre></td></tr></table></figure>

<p>state 改变引发重新渲染的时机</p>
<p>现在我们知道应该用 setState 函数来修改组件 state，而且可以引发组件重新渲染，有意思的是，并不是一次 setState 调用肯定会引发一次重新渲染。</p>
<p>这是 React 的一种性能优化策略，如果 React 对每一次 setState 都立刻做一次组件重新渲染，那代价有点大，比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: 1&#125;);</span><br><span class="line">this.setState(&#123;caption: &#x27;foo&#x27;&#125;);</span><br><span class="line">this.setState(&#123;count: 2&#125;);</span><br></pre></td></tr></table></figure>

<p>连续的同步调用 setState，第三次还覆盖了第一次调用的效果，但是效果只相当于调用了下面这样一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: 2, caption: &#x27;foo&#x27;&#125;);</span><br></pre></td></tr></table></figure>

<p>虽然明智的开发者不会故意连续写三个 setState 调用，但是代码一旦写得复杂，可能有多个 setState 分布在一次执行的不同代码片段中，还是会同步连续调用 setState，这时候，如果真的每个 setState 都引发一次重新渲染，实在太浪费了。</p>
<p>React 非常巧妙地用任务队列解决了这个问题，可以理解为每次 setState 函数调用都会往 React 的任务队列里放一个任务，多次 setState 调用自然会往队列里放多个任务。React 会选择时机去批量处理队列里执行任务，当批量处理开始时，React 会合并多个 setState 的操作，比如上面的三个 setState 就被合并为只更新 state 一次，也只引发一次重新渲染。</p>
<p>因为这个任务队列的存在，React 并不会同步更新 state，所以，在 React 中，setState 也不保证同步更新 state 中的数据。</p>
<p><strong>state 不会被同步修改</strong></p>
<p>简单说来，调用 setState 之后的下一行代码，读取 this.state 并不是修改之后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.state.count);// 修改之前this.state.count为0</span><br><span class="line">this.setState(&#123;count: 1&#125;)</span><br><span class="line">console.log(this.state.count);// 在这里this.state.count依然为0</span><br></pre></td></tr></table></figure>

<p>这乍看是很让人费解的结果，但是如果你理解了上面 React 任务队列的设计，一切也不难理解。</p>
<p>setState 只是给任务队列里增加了一个修改 this.state 的任务，这个任务并没有立即执行，所以 this.state 并不会立刻改变。</p>
<p>好吧，其实问题也没有那么简单，上面我所举的例子中，都假设 setState 是由 React 的生命周期函数或者事件处理函数中同步调用，这种情况下 setState 不会立即同步更新 state 和重新渲染，但是，如果调用 setState 由其他条件引发，就不是这样了。</p>
<p>看下面的代码，结果可能会出乎你的所料：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  this.setState(&#123;count: 2&#125;); //这会立刻引发重新渲染</span><br><span class="line">  console.log(this.state.count); //这里读取的count就是2</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure>

<p>为什么 setTimeout 能够强迫 setState 同步更新 state 呢？</p>
<p>可以这么理解，当 React 调用某个组件的生命周期函数或者事件处理函数时，React 会想：“嗯，这一次函数可能调用多次 setState，我会先打开一个标记，只要这个标记是打开的，所有的 setState 调用都是往任务队列里放任务，当这一次函数调用结束的时候，我再去批量处理任务队列，然后把这个标记关闭。”</p>
<p>因为 setTimeout 是一个 JavaScript 函数，和 React 无关，对于 setTimeout 的第一个函数参数，这个函数参数的执行时机，已经不是 React 能够控制的了，换句话说，React 不知道什么时候这个函数参数会被执行，所以那个“标记”也没有打开。</p>
<p>当那个“标记”没有打开时，setState 就不会给任务列表里增加任务，而是强行立刻更新 state 和引发重新渲染。这种情况下，React 认为：“这个 setState 发生在自己控制能力之外，也许开发者就是想要强行同步更新呢，宁滥勿缺，那就同步更新了吧。”</p>
<p>知道这个“技巧”之后，可能会有开发者说：好啊，那么以后我就用 setTimeout 来调用 setState 吧，能够立刻更新 state，多好！</p>
<p>我劝你不要这么做。</p>
<p>就像上面所说，React 选择不同步更新 state，是一种性能优化，如果你用上 setTimeout，就没机会让 React 优化了。</p>
<p>而且，每当你觉得需要同步更新 state 的时候，往往说明你的代码设计存在问题，绝大部分情况下，你所需要的，并不是“state 立刻更新”，而是，“确定 state 更新之后我要做什么”，这就引出了 setState 另一个功能</p>
<p><strong>setState 的第二个参数</strong></p>
<blockquote>
<p>setState 的第二个参数可以是一个回调函数，当 state 真的被修改时，这个回调函数会被调用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.state.count); // 0</span><br><span class="line">this.setState(&#123;count: 1&#125;, () =&gt; &#123;</span><br><span class="line">    console.log(this.state.count); // 这里就是1了</span><br><span class="line">&#125;)</span><br><span class="line">console.log(this.state.count); // 依然为0</span><br></pre></td></tr></table></figure>

<p>当 setState 的第二个参数被调用时，React 已经处理完了任务列表，所以 this.state 就是更新后的数据。</p>
<p>如果需要在 state 更新之后做点什么，请利用第二个参数。</p>
<p><strong>函数式 setState</strong></p>
<p>不管怎么说，setState 不能同步更新的确会带来一些麻烦，尤其是多个 setState 调用之间有依赖关系的时候，很容易写错代码。</p>
<p>一个很典型的例子，当我们不断增加一个 state 的值时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">this.setState(&#123;count: this.state.count + 1&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码表面上看会让 this.state.count 增加 3，实际上只增加了 1，因为 setState 没有同步更新 this.state 啊，所以给任务队列加的三个任务都是给 this.state.count 同一个值而已。</p>
<p>面对这种情况，我们很自然地想到，如果任务列表中的任务不只是给 state 一个固定数据，如果任务列表里的“任务”是一个函数，能够根据当前 state 计算新的状态，那该多好！</p>
<p>实际上，setState 已经支持这种功能，到现在为止我们给 setState 的第一个参数都是对象，其实也可以传入一个函数。</p>
<p>当 setState 的第一个参数为函数时，任务列表上增加的就是一个可执行的任务函数了，React 每处理完一个任务，都会更新 this.state，然后把新的 state 传递给这个任务函数。</p>
<p>setState 第一个参数的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function increment(state, props) &#123;</span><br><span class="line">  return &#123;count: state.count + 1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这是一个纯函数，不光接受当前的 state，还接受组件的 props，在这个函数中可以根据 state 和 props 任意计算，返回的结果会用于修改 this.state。</p>
<p>如此一来，我们就可以这样连续调用 setState：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(increment);</span><br><span class="line">this.setState(increment);</span><br><span class="line">this.setState(increment);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用这种函数式方式连续调用 setState，就真的能够让 this.state.count 增加 3，而不只是增加 1。</p>
</blockquote>
<h3 id="5-2-Mobx-使用模式"><a href="#5-2-Mobx-使用模式" class="headerlink" title="5.2 Mobx 使用模式"></a>5.2 Mobx 使用模式</h3><p><strong>理解 Mobx</strong></p>
<blockquote>
<p>虽然 Mobx 和 Redux 有很大不同，但是至少还有一个共同点——这两个工具都和 React 没有任何直接关系，只不过凑巧 React 社区大量使用它们罢了。从技术上说，Mobx 和 Redux 都是中立的状态管理工具，他们能够应用于 React，也可以用于其他需要状态管理的场景</p>
</blockquote>
<p>我们用 Mobx 来实现一个很简单的计数工具，首先，需要有一个对象来记录计数值，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;observable&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">const counter = observable(&#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，counter 是一个对象，其实就是用 observable 函数包住一个普通 JavaScript 对象，但是 observable 的介入，让 counter 对象拥有了神力。</p>
<p>我们用最简单的代码来展示这种“神力”，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;autorun&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">window.counter = counter;</span><br><span class="line"></span><br><span class="line">autorun(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;#count&#x27;, counter.count);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>把 counter 赋值给 window.counter，是为了让我们在 Chrome 的开发者界面可以访问。用 autorun 包住了一个函数，这个函数输出 counter.count 的值，这段代码的作用，我们很快就能看到。</p>
<p>在 Chrome 的开发者界面，我们可以直接访问 window.counter.count，神奇之处是，如果我们直接修改 window.counter.count 的值，可以直接触发 autorun 的函数参数！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf8e6c419c97e" alt="img"></p>
<p>这个现象说明，mobx 的 observable 拥有某种“神力”，任何对这个对象的修改，都会立刻引发某些函数被调用。和 observable 这个名字一样，被包装的对象变成了“被观察者”，而被调用的函数就是“观察者”，在上面的例子中，autorun 的函数参数就是“观察者”。</p>
<p>Mobx 这样的功能，等于实现了设计模式中的“观察者模式”（Observer Pattern），通过建立 observer 和 observable 之间的关联，达到数据联动。不过，传统的“观察者模式”要求我们写代码建立两者的关联，也就是写类似下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.register(observer);</span><br></pre></td></tr></table></figure>

<p>Mobx 最了不起之处，在于不需要开发者写上面的关联代码，Mobx自己通过解析代码就能够自动发现 observer 和 observable 之间的关系。</p>
<p>我们很自然想到，如果让我们的数据拥有这样的“神力”，那我们就不用在修改完数据之后，再费心去调用某些函数使用这些数据了，数据管理会变得十分轻松。</p>
<p><strong>decorator</strong></p>
<p>因为 Mobx 的作用就是把简单的对象赋予神力，总要有一种方法能够在不改变对象代码的前提，去改变对象的行为，这就用得上“装饰者模式”（Decorator Pattern）。</p>
<p>单独说“装饰者模式”，这只是面向对象编程思想下的一种模式，不过对 JavaScript 语言而言，就不只是一种模式，而是一种语言特性，它在语法上对这种模式提供了强大的支持，所谓强大，就是指使用起来代码极其简洁。</p>
<p>根据 JavaScript 语法，我们可以这样创造一个 decorator，叫做 log：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log(target, name, descriptor) &#123;</span><br><span class="line">  console.log(&#x27;#target&#x27;, target);</span><br><span class="line">  console.log(&#x27;#name&#x27;, name);</span><br><span class="line">  console.log(&#x27;#descriptor&#x27;, descriptor);</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，很明显这个 decorator 什么实质的事情都没做，只是用 console.log 输出了三个参数秀了一下存在感，最后返回的 descriptor，就是被这个『装饰者』所『装饰』的对象。</p>
<p>下面是使用这个 decorator 的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">class Bar &#123;</span><br><span class="line">  @log</span><br><span class="line">  bar() &#123;</span><br><span class="line">    console.log(&#x27;bar&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，@ 符号就是使用 decorator 的标志，将 @log 作用于一个类 Bar，那么最后得到的 Bar 其实是调用 log 函数返回的结果；将 @log 作用于一个类成员 @bar，最后得到的 bar 同样是调用 log 函数之后得到的结果。可见，如果我们巧妙地编写 log 函数，控制返回的结果，就可以操纵被『装饰』的类或者成员。</p>
<p>编写 decorator 是一个复杂的过程，也超出了这本小册的范围，有兴趣的读者可以自行研究。在这里，读者只需要知道，虽然使用 Mobx 并不是必须使用 decorator，但是使用 decorator 会让 Mobx 的应用代码简洁易读很多</p>
<p><strong>用 decorator 来使用 Mobx</strong></p>
<p>还是以 Counter 为例，看如何用 decorator 使用 Mobx，我们先看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123;observable&#125; from &#x27;mobx&#x27;;</span><br><span class="line">import &#123;observer&#125; from &#x27;mobx-react&#x27;;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  @observable count = 0;</span><br><span class="line"></span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    this.count ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    this.count --;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#x27;#enter componentWillUpdate&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;CounterView</span><br><span class="line">        caption=&quot;With decorator&quot;</span><br><span class="line">        count=&#123;this.count&#125;</span><br><span class="line">        onIncrement=&#123;this.onIncrement&#125;</span><br><span class="line">        onDecrement=&#123;this.onDecrement&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，Counter 这个 React 组件自身是一个 observer，而 observable 是 Counter 的一个成员变量 count。</p>
<p>注意 observer 这 个decorator 来自于 mobx-react，它是 Mobx 世界和 React 的桥梁，被它“装饰”的组件，只要用到某个被 Mobx 的 observable “装饰”过的数据，自然会对这样的数据产生反应。所以，只要 Counter 的 count 成员变量一变化，就会引发 Counter 组件的重新渲染。</p>
<p>可以注意到，Counter 的代码中并没有自己的 state，其实，被 observer 修饰过之后，Counter 被强行”注入”了 state，只不过我们看不见而已。</p>
<p><strong>独立的 Store</strong></p>
<p>虽然把 observer 和 observable 集中在一个 React 组件中可行，但是，这也让 observable 的状态被封存在了 React 组件内，那我们直接用 React 自身的 state 管理也能解决问题，所以，这样使用 Mobx 意义不大。</p>
<p>更多适用于 Mobx 的场合，就和适用于 Redux 的场合一样，是一个状态需要多个组件共享，所以 observable 一般是在 React 组件之外。</p>
<p>我们重写一遍 Counter 组件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const store = observable(&#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;);</span><br><span class="line">store.increment = function() &#123;</span><br><span class="line">  this.count ++;</span><br><span class="line">&#125;;</span><br><span class="line">store.decrement = function() &#123;</span><br><span class="line">  this.count --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@observer // this decorator is must</span><br><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  onIncrement = () =&gt; &#123;</span><br><span class="line">    store.increment();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onDecrement = () =&gt; &#123;</span><br><span class="line">    store.decrement();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;CounterView</span><br><span class="line">        caption=&quot;With external state&quot;</span><br><span class="line">        count=&#123;store.count&#125;</span><br><span class="line">        onIncrement=&#123;this.onIncrement&#125;</span><br><span class="line">        onDecrement=&#123;this.onDecrement&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，我们把 count 提到组件之外，甚至就把它叫做 store，这延续的是 Redux 的命名方法</p>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li>Mobx 的基本功能就是“观察者模式”</li>
<li>decorator 是“装饰者模式”在 JavaScript 语言中的实现</li>
<li>Mobx 通常利用 decorator 来使用</li>
</ul>
<h3 id="5-3-不同方式对比"><a href="#5-3-不同方式对比" class="headerlink" title="5.3 不同方式对比"></a>5.3 不同方式对比</h3><p><strong>Mobx 和 Redux 的比较</strong></p>
<p>Mobx 和 Redux 的目标都是管理好应用状态，但是最根本的区别在于对数据的处理方式不同。</p>
<p>Redux 认为，数据的一致性很重要，为了保持数据的一致性，要求Store 中的数据尽量范式化，也就是减少一切不必要的冗余，为了限制对数据的修改，要求 Store 中数据是不可改的（Immutable），只能通过 action 触发 reducer 来更新 Store。</p>
<p>Mobx 也认为数据的一致性很重要，但是它认为解决问题的根本方法不是让数据范式化，而是不要给机会让数据变得不一致。所以，Mobx 鼓励数据干脆就“反范式化”，有冗余没问题，只要所有数据之间保持联动，改了一处，对应依赖这处的数据自动更新，那就不会发生数据不一致的问题。</p>
<p>值得一提的是，虽然 Mobx 最初的一个卖点就是直接修改数据，但是实践中大家还是发现这样无组织无纪律不好，所以后来 Mobx 还是提供了 action 的概念。和 Redux 的 action 有点不同，Mobx 中的 action 其实就是一个函数，不需要做 dispatch，调用就修改对应数据，在上面的代码中，increment 和 decrement 就是 action。</p>
<p>如果想强制要求使用 action，禁止直接修改 observable 数据，使用 Mobx 的 configure，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;configure&#125; from &#x27;mobx&#x27;;</span><br><span class="line"></span><br><span class="line">configure(&#123;enforceActions: true&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>总结一下 Redux 和 Mobx 的区别，包括这些方面：</strong></p>
<ul>
<li>Redux 鼓励一个应用只用一个 Store，Mobx 鼓励使用多个 Store；</li>
<li>Redux 使用“拉”的方式使用数据，这一点和 React是一致的，但 Mobx 使用“推”的方式使用数据，和 RxJS 这样的工具走得更近；</li>
<li>Redux 鼓励数据范式化，减少冗余，Mobx 容许数据冗余，但同样能保持数据一致。</li>
</ul>
<h2 id="六、React-Router"><a href="#六、React-Router" class="headerlink" title="六、React Router"></a>六、React Router</h2><p>随着 AJAX 技术的成熟，现在单页应用（Single Page Application）已经是前端网页界的标配，名为“单页”，其实在设计概念上依然是多页的界面，只不过从技术层面上页之间的切换是没有整体网页刷新的，只需要做局部更新。</p>
<p>要实现“单页应用”，一个最要紧的问题就是做好“路由”（Routing)，也就是处理好下面两件事：</p>
<ul>
<li>把 URL 映射到对应的页面来处理；</li>
<li>页面之间切换做到只需局部更新。</li>
</ul>
<p><strong>react router v4 的动态路由</strong></p>
<ul>
<li>我们现在说到 react-router，基本上都是在说 react-router 的第 4 版，也就是 v4。这个 v4 很有意思，它完全推翻了之前 v3 的做法。可以说，react-router 的 v3 和 v4 版完完全全是不同的两个工具，两者差距实在太大。</li>
<li>其实当初 v3 也已经很优秀很热门了，但是 react-router 的开发者不满意，他们认为 v3 还是落入了“静态路由”的窠臼，所以在 v4 中 react-router 做到了“动态路由”的功能。</li>
<li>所谓“静态路由”，就是说路由规则是固定的，无论 express、Angular 还是 Rails 等业界响当当的框架，都用的是静态路由。以 express 为例，路由规则差不多是这么写的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#x27;/&#x27;, Home);</span><br><span class="line">app.get(&#x27;/product/:id&#x27;, Product);</span><br><span class="line">app.get(&#x27;/about&#x27;, About);</span><br></pre></td></tr></table></figure>

<p>对于大部分应用，支持这样的路由规则真的是足够了，但是，react-router 的开发者觉得这样还不够好，要支持“动态路由”才是最好。</p>
<p>所谓动态路由，指的是路由规则不是预先确定的，而是在渲染过程中确定的。因为 react-router 的定位就是专供 React 应用服务，而 React 的世界中一切皆为组件，所以 react-router v4 就完全用 React 组件来实现路由功能。</p>
<p>不得不承认，虽然 react-router 的开发者是挺折腾的，但是他们的确是领悟了 React 的精髓，而且在 react-router 中把 React 的哲学发挥到了极致。</p>
<p>接下来，我们通过一个很简单的例子来说明 react-router v4 如何工作的，然后在这个例子的基础上介绍“动态路由”。</p>
<p><strong>React Router 实例</strong></p>
<p>安装包 react-router-dom</p>
<p>create-react-app 产生的应用默认为不支持多个页面，但还是在 README 文件中友情推荐了一下 react-router 来增强功能，可见 react-router 影响力之大。</p>
<p>不过，我们并不需要安装 react-router 这个 npm 包，因为 react-router 为了支持 Web 和 React Native 出了两个包—— react-router-dom 和 react-router-native ，我们只关心 Web，所以只需要安装 react-router-dom 。这个 react-router-dom 依赖于 react-router ，所以 react-router 也会被自动安装上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br></pre></td></tr></table></figure>

<p><strong>HashRouter 还是 BrowserRouter</strong></p>
<p>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p>
<p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p>
<p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p>
<p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p>
<p>第二种看起来不自然，但是实现更简单。只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</p>
<p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p>
<p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p>
<p>修改index.js文件，增加下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p>
<p><strong>使用 Link</strong></p>
<p>对于单页应用，需要在不同“页面”之间切换，往往需要一个“导航栏”，我们在这里也实现一个简单的导航栏。</p>
<p>在App.js中，我们让网页由两个组件 Navigation 和 Content 组成， Navigation 就是导航栏，而 Content 是具体内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;Navigation /&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们计划只增加两个页面，在 Navigation 中就应该有两个链接，但是，如果我们简单使用 HTML 的 标签那就错了，用户点击 标签缺省行为是网页跳转，这违背了“单页应用”的原则。虽然对于 HashRouter 使用的是没有网页跳转的 #，但是为了将来可以无缝切换为 BrowserRouter ，我们也不能使用 <code>[</code>](#about) 这样的标签。</li>
<li>正确的解法是用 react-router 提供的 Link 组件，虽然 Link 最终还是渲染为 标签，但这是有神力的 标签，用户点击时，react-router 可以知晓这是一个单页应用的链接，不用网页跳转只做局部页面更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ulStyle = &#123;</span><br><span class="line">  &#x27;list-style-type&#x27;: &#x27;none&#x27;,</span><br><span class="line">  margin: 0,</span><br><span class="line">  padding: 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const liStyle = &#123;</span><br><span class="line">  display: &#x27;inline-block&#x27;,</span><br><span class="line">  width: &#x27;60px&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Navigation = () =&gt; (</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">      &lt;ul style=&#123;ulStyle&#125;&gt;</span><br><span class="line">        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/&#x27;&gt;Home&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li style=&#123;liStyle&#125;&gt;&lt;Link to=&#x27;/about&#x27;&gt;About&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>使用 Route 和 Switch</strong></p>
<p>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p>
<p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p>
<p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p>
<p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p>
<p><strong>动态路由</strong></p>
<p>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p>
<p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p>
<p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&#x27;/&#x27; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    isUserLogin() &amp;&amp;</span><br><span class="line">    &lt;Route exact path=&#x27;/product&#x27; component=&#123;Product&#125;/&gt;,</span><br><span class="line">  &#125;  </span><br><span class="line">  &lt;Route path=&#x27;/about&#x27; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用任何条件决定 <code>Route</code> 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度</p>
</blockquote>
<h2 id="七、服务器端渲染"><a href="#七、服务器端渲染" class="headerlink" title="七、服务器端渲染"></a>七、服务器端渲染</h2><h3 id="7-1-基本套路"><a href="#7-1-基本套路" class="headerlink" title="7.1 基本套路"></a>7.1 基本套路</h3><p><strong>为什么要服务器端渲染</strong></p>
<p>最近几年浏览器端框架很繁荣，以至于很多新入行的开发者只知道浏览器端渲染框架，都不知道存在服务器端渲染这回事，其实，网站应用最初全都是服务器端渲染，由服务器端用 PHP、Java 或者 Python 等其他语言产生 HTML 来给浏览器端解析。</p>
<p>相比于浏览器端渲染，服务器端渲染的好处是：</p>
<p>1、可以缩短“第一有意义渲染时间”（First-Meaningful-Paint-Time）。</p>
<p>如果完全依赖于浏览器端渲染，那么服务器端返回的 HTML 就是一个空荡荡的框架和对 JavaScript 的应用，然后浏览器下载 JavaScript，再根据 JavaScript 中的 AJAX 调用获取服务器端数据，再渲染出 DOM 来填充网页内容，总共需要三个 HTTP 或 HTTPS 请求。</p>
<p>如果使用服务器端渲染，第一个 HTTP/HTTPS 请求返回的 HTML 里就包含可以渲染的内容了，这样用户第一时间就会感觉到“有东西画出来了”，这样的感知性能更好。</p>
<p>2、更好的搜索引擎优化（Search-Engine-Optimization，SEO）</p>
<p>大部分网站都希望自己能够出现在搜索引擎的搜索页前列，这个前提就是网页内容要能够被搜索引擎的爬虫正确抓取到。虽然 Google 这样的搜索引擎已经可以检索浏览器端渲染的网页，但毕竟不是全部搜索引擎都能做到，如果搜索引擎的爬虫只能拿到服务器端渲染的内容，完全浏览器端渲染就行不通了。</p>
<p>即使对于 Google，网页性能也是搜索排名的重要指标，如果通过服务器端渲染提高网页性能，网页的排名更可能靠前。</p>
<p>上面两点，就是服务器端渲染的主要意义。</p>
<p><strong>React 对服务器端渲染的支持</strong></p>
<p>因为 React 是声明式框架，所以，在渲染上对服务器端渲染非常友好。</p>
<p>假设我们我们要渲染一个以 App 为最根节点的组件树，浏览器端渲染的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>现在我们想要在服务器端渲染 App，如果使用 React v16 之前的版本，代码是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">// 把产生html返回给浏览器端</span><br><span class="line">const html = ReactDOMServer.renderToString(&lt;Hello /&gt;);</span><br></pre></td></tr></table></figure>

<p>从 React v16 开始，上面的服务器端代码依然可以使用，但是也可以把 renderToString 替换为 renderToNodeStream，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">// 把渲染内容以流的形式塞给response</span><br><span class="line">ReactDOMServer.renderToNodeStream(&lt;Hello /&gt;).pipe(response);</span><br></pre></td></tr></table></figure>

<p>此外，浏览器端代码也有一点变化，ReactDOM.render 依然可以使用，但是官方建议替换为 ReactDOM.hydrate，原来的 ReactDOM.render 将来会被废弃掉。</p>
<p>renderToString 的功能是一口气同步产生最终 HTML，如果 React 组件树很庞大，这样一个同步过程可能比较耗时。假设渲染完整 HTML 需要 500 毫秒，那么一个 HTTP/HTTPS 请求过来，500 毫秒之后才返回 HTML，显得不大合适，这也是为什么 v16 提供了 renderToNodeStream 这个新 API 的原因。</p>
<p>renderToNodeStream 把渲染结果以“流”的形式塞给 response 对象（这里的 response 是 express 或者 koa 的概念），这意味着不用等到所有 HTML 都渲染出来了才给浏览器端返回结果，也许 10 毫秒内就渲染出来了网页头部，那就没必要等到 500 毫秒全部网页都出来了才推给浏览器，“流”的作用就是有多少内容给多少内容，这样用户只需要 10 毫秒多一点的延迟就可以看到网页内容，进一步改进了“第一有意义渲染时间”</p>
<p><strong>服务器端渲染的难点</strong></p>
<p>看到这里，你可能觉得服务器端渲染也太简单了，的确，因为 React 组件可以不必关心自己是在哪个端渲染，可以做到代码一次编写，到处都可以执行。但是，真的这么简单吗？</p>
<p>为了简化问题，上面的代码示例有意忽略了一个事实，那就是，应用往往需要外部服务器获取数据啊！</p>
<p>除非你的网页应用根本没有动态内容，不然你必须要考虑在服务器端怎么给 React 组件获取数据。</p>
<p>比如，你现在看到的掘金小册，为了渲染你所看到的页面，需要调用掘金小册的服务器 API 来获取这篇文章的内容。对于浏览器端渲染，在 componentDidMount 里调用 AJAX 就好了；对于服务器端渲染，要想产生 HTML 的包含内容，必须事先把数据准备好，也就是说，代码要是这样才行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOMServer from &#x27;react-dom/server&#x27;;</span><br><span class="line"></span><br><span class="line">callAPI().then(result =&gt; &#123;</span><br><span class="line">  const props = result;</span><br><span class="line">  ReactDOMServer.renderToNodeStream(&lt;Hello &#123;...props&#125;/&gt;).pipe(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最大的问题来了，如何给组件获取和提供数据呢？</p>
<p>解决了这个问题，才算真的解决了服务器端渲染的问题。</p>
<p><strong>“脱水”和“注水”8</strong></p>
<p>React 有一个特点，就是把内容展示和动态功能集中在一个组件中。比如，一个 Counter 组件既负责怎么画出内容，也要负责怎么响应按键点击，这当然符合软件高内聚性的原则，但是也给服务器端渲染带来更多的工作。</p>
<p>设想一下，如果只使用服务器端渲染，那么产生的只有 HTML，虽然能够让浏览器端画出内容，但是，没有 JavaScript 的辅助是无法响应用户交互事件的。对应 Counter 的例子，一个 Counter 组件在浏览器中也就渲染出一个数字两个按钮，用户点击 + 按钮或者 - 按钮，什么都不会发生。</p>
<p>很显然我们必须要在浏览器端赋予 Counter 组件一些“神力”，让它能够响应事件。那么怎么赋予 Counter 组件“神力”呢？其实我们已经做过这件事了，Counter 组件里面已经有对按钮事件的处理，我们所要做的只是让 Counter 组件在浏览器端重新执行一遍，也就是 mount 一遍就可以了。</p>
<blockquote>
<p>也就是说，如果想要动态交互效果，使用 React 服务器端渲染，必须也配合使用浏览器端渲染。</p>
</blockquote>
<p>现在问题变得更加有趣了，在服务器端我们给 Counter 一个初始值（这个值可以不是缺省的 0），让 Counter 渲染产生 HTML，这些 HTML 要传递给浏览器端，为了让 Counter 的 HTML“活”起来点击相应事件，必须要在浏览器端重新渲染一遍 Counter 组件。在浏览器端渲染 Counter 之前，用户就可以看见 Counter 组件的内容，但是无法点击交互，要想点击交互，就必须要等到浏览器端也渲染一次 Counter 之后。</p>
<p>接下来的一个问题，如果服务器端塞给 Counter 的数据和浏览器端塞给 Counter 的数据不一样呢？</p>
<p>在 React v16 之前，React 在浏览器端渲染之后，会把内容和服务器端给的 HTML 做一个比对。如果完全一样，那最好，接着用服务器端 HTML 就好了；如果有一丁点不一样，就会立刻丢掉服务器端的 HTML，重新渲染浏览器端产生的内容，结果就是用户可以看到界面闪烁。因为 React 抛弃的是整个服务器端渲染内容，组件树越大，这个闪烁效果越明显。</p>
<p>React 在 v16 之后，做了一些改进，不再要求整个组件树两端渲染结果分毫不差，但是如果发生不一致，依然会抛弃局部服务器端渲染结果。</p>
<blockquote>
<p>总之，如果用服务器端渲染，一定要让服务器端塞给 React 组件的数据和浏览器端一致。</p>
</blockquote>
<p>为了达到这一目的，必须把传给 React 组件的数据给保留住，随着 HTML 一起传递给浏览器网页，这个过程，叫做“脱水”（Dehydrate）；在浏览器端，就直接拿这个“脱水”数据来初始化 React 组件，这个过程叫“注水”（Hydrate）。</p>
<p>前面提到过 React v16 之后用 React.hydrate 替换 React.render，这个 hydrate 就是“注水”。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/2/166d20bf04d0775d" alt="img"></p>
<blockquote>
<p>总之，为了实现React的服务器端渲染，必须要处理好这两个问题：</p>
</blockquote>
<ul>
<li>脱水</li>
<li>注水</li>
</ul>
<p><strong>Facebook 未使用服务器端渲染</strong></p>
<p>值得一提的是，虽然 React 从最初版本就支持“服务器端渲染”，并且 React 的创建者 Facebook 也全力在自己的网站产品中使用 React，但他们自己却没有使用 React 的服务器端渲染功能。理由是，Facebook 已经在 PHP 上投入了很多资源，不打算放弃这些投入。</p>
<p>这里我当然不是批评 Facebook，实际上，Facebook 对 React 的支持是真心的，它在自己的网站上大范围使用 React，而不只是做出来后让外部使用者当小白鼠，这种全力投入也给了 React 使用者很大信心。但另一方面，因为 Facebook 自己不用 React 的服务器端渲染，如何利用这个功能，就缺乏一个官方参考标准了。</p>
<p>也许就是因为缺乏 Facebook 的官方标准，业界对服务器端渲染的解决方法层出不穷，不过，到目前看来，next.js 还是最佳方案</p>
<h3 id="7-2-理解-Next-js"><a href="#7-2-理解-Next-js" class="headerlink" title="7.2 理解 Next.js"></a>7.2 理解 Next.js</h3><p>我们已经知道了服务器端渲染的原理，你只需要搭建一个 Express 服务器，在服务器端手工打造『脱水』，在浏览器端做『注水』，完成某个页面的服务器端渲染并不难。</p>
<p>不过，服务器端渲染的问题并不这么简单，一个最直接的问题，就是怎么处理多个页面的『单页应用』（Single-Page-Application）？</p>
<p>所以单页应用，就是虽然用户感觉有多个页面，但是实现上只有一个页面，用户感觉到页面可以来回切换，但其实只是一个页面并没有完全刷新，只是局部界面更新而已。</p>
<p>假设一个单页应用有三个页面 Home、Prodcut 和 About，分别对应的的路径是 /home、/product 和 /about，而且三个页面都依赖于 API 调用来获取外部数据。</p>
<p>现在我们要做服务器端渲染，如果只考虑用户直接在地址栏输入 /home、/product 和 /about 的场景，很容易满足，按照上面说的套路做就是了。但是，这是一个单页应用，用户可以在 Home 页面点击链接无缝切换到 Product，这时候 Product 要做完全的浏览器端渲染。换句话说，每个页面都需要既支持服务器端渲染，又支持完全的浏览器端渲染，更重要的是，对于开发者来说，肯定不希望为了这个页面实现两套程序，所以必须有同时满足服务器端渲染和浏览器端渲染的代码表示方式。</p>
<p>读者可以思考一下什么样的代码表示合适，也可以直接往下，看看业界公认最科学的实现方式 Next.js 是如何做的。</p>
<p><strong>快速创建 Next.js 项目</strong></p>
<p>在说明 Next.js 的工作原理之前，我们先看怎么快速创建 Next.js 项目，这个问题用代码来说明会更顺畅。</p>
<p>我们也可以手工创建 Next.js 项目，不过更简单的方式是用自动化工具 create-next-app，这个 create-next-app 类似于 create-react-app，一个命令就创建一个可以运行的应用。</p>
<p>首先安装 create-next-app。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-next-app</span><br></pre></td></tr></table></figure>

<p>然后，就可以在你专门存放项目的目录下执行 create-next-app，产生一个使用 Next.js 的 React 应用，下面的命令创建一个叫 next_demo 的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-next-app next_demo</span><br></pre></td></tr></table></figure>

<p>进入新生成的项目目录 next_demo 里检查一下，可以看到文件结构非常简洁，pages 目录下是页面文件，package.json 中差不是下面这样，没有繁冗的 webpack 和 babel 依赖包，因为一切都被 Next.js 封装起来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;create-next-example-app&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;next&quot;: &quot;^6.0.3&quot;,</span><br><span class="line">    &quot;react&quot;: &quot;^16.5.2&quot;,</span><br><span class="line">    &quot;react-dom&quot;: &quot;^16.5.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有不少框架都表示自己的功能很强大，但其中有很多框架的设计并不中立，用这些框架去开发某些特定应用或许还行，如果放到一个更大范围的应用类型中，就会发现无法满足要求，这样的框架通用性不足，开发者一定要谨慎使用。</p>
<p>讲良心话，Next.js 真的是一个通用性非常高的框架，因为 Next.js 完全遵从了 React 的技术哲学：一切皆为组件。</p>
<p>在 Next.js 中，创造一个页面，其实就是创造一个 React 组件，接下来我们看看如何创建一个页面。</p>
<p><strong>编写页面</strong></p>
<p>使用下面的命令启动 Next.js 应用，进入的是开发者模式，这时候对代码的改变，会立刻体现在网页上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>请注意，这一点上 Next.js 的习惯用法和 create-react-app 产生的应用不一样。在 create-react-app 产生的应用中， npm run start 启动是开发者模式，但在 Next.js 应用中，习惯上 npm run start 以产品模式启动，所以要先运行 npm run build 然后才能运行 npm run start。</p>
<p>Next.js 遵从『协定优于配置』（convention over configuration）的设计原则，根据『协定』，在 pages 中每个文件对应一个网页文件，文件名对应的就是网页的路径名，比如 pages/home.js 文件对应的就是 /home 路径的页面，当然 pages/index.js 比较特殊，对应的是默认根路径 / 的页面。</p>
<p>我们修改 pages/index.js，让它更简单一些，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">const Home = (props) =&gt; (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello World</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure>

<p>这样会在页面上显示出一个 Hello World，而这个页面代码就是一个普通的 React 组件而已。</p>
<p>页面都是 React 组件，这就是 Next.js 的哲学。</p>
<p><strong>getInitialProps</strong></p>
<p>我们还是要回到本来的话题，如何优雅地实现服务器端渲染，上面的 Home 页面虽然能够渲染出完整包含 Hello World 的 HTML，但是并没有调用任何外部 API 资源，所以也没有异步操作，并不能体现服务器端渲染的难度。</p>
<p>我们用一个函数来实现异步操作，以此模拟调用 API 的延迟效果，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const timeout = (ms, result) =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(result), ms));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后，我们利用这个 timeout 来获得展示网页所需的数据。比如说，获取用户名，那么我们的 Home 组件就要换一个写法，像下面那样，增加 getInitialProps 的定义：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Home = (props) =&gt; (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello &#123;props.userName&#125;</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Home.getInitialProps = async () =&gt; &#123;</span><br><span class="line">  return await timeout(200, &#123;userName: &#x27;Morgan&#x27;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 getiInitialProps 是 Next.js 最伟大的发明，它确定了一个规范，一个页面组件只要把访问 API 外部资源的代码放在 getInitialProps 中就足够，其余的不用管，Next.js 自然会在服务器端或者浏览器端调用 getInitialProps 来获取外部资源，并把外部资源以 props 的方式传递给页面组件。</p>
<p>注意 getInitialProps 是页面组件的静态成员函数，可以用下面的方法定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Home.getInitialProps = async () = &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以在组件类中加上 static 关键字定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Home extends React.Component &#123;</span><br><span class="line">  static async getInitialProps() &#123;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我么也可以注意到，getInitialProps 是一个 async 函数，所以，在 getInitialProps 函数中可以使用 await 关键字，用同步的方式编写异步逻辑。</p>
<p>我们可以这样来看待 getInitialProps，它就是 Next.js 对代表页面的 React 组件生命周期的扩充。React 组件的生命周期函数缺乏对异步操作的支持，所以 Next.js 干脆定义出一个新的生命周期函数 getInitialProps，在调用 React 原生的所有生命周期函数之前，Next.js 会调用 getInitialProps 来获取数据，然后把获得数据作为 props 来启动 React 组件的原生生命周期过程。</p>
<p><strong>这个生命周期函数的扩充十分巧妙，因为：</strong></p>
<ul>
<li>没有侵入 React 原生生命周期函数，以前的 React 组件该怎么写还是怎么写；</li>
<li>getInitialProps 只负责获取数据的过程，开发者不用操心什么时候调用 getInitialProps，依然是 React 哲学的声明式编程方式；</li>
<li>getInitialProps 是 async 函数，可以利用 JavaScript 语言的新特性，用同步的方式实现异步功能。</li>
</ul>
<p><strong>Next.js 的“脱水”和“注水”</strong></p>
<p>我们说过服务器端渲染的关键是如何“脱水”和“注水”，如果你对 Next.js 如何实现这两个关键点好奇（实际上你确实应该感到好奇），那么在浏览器中使用“显示网页源代码”就可以让你一目了然。</p>
<p>在网页的 HTML 中，可以看到类似下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  __NEXT_DATA__ = &#123;</span><br><span class="line">    &quot;props&quot;:&#123;</span><br><span class="line">      &quot;pageProps&quot;: &#123;&quot;userName&quot;:&quot;Morgan&quot;&#125;&#125;,</span><br><span class="line">      &quot;page&quot;:&quot;/&quot;,&quot;pathname&quot;:&quot;/&quot;,&quot;query&quot;:&#123;&#125;,&quot;buildId&quot;:&quot;-&quot;,&quot;assetPrefix&quot;:&quot;&quot;,&quot;nextExport&quot;:false,&quot;err&quot;:null,&quot;chunks&quot;:[]&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>Next.js 在做服务器端渲染的时候，页面对应的 React 组件的 getInitialProps 函数被调用，异步结果就是“脱水”数据的重要部分，除了传给页面 React 组件完成渲染，还放在内嵌 script 的 <strong>NEXT_DATA</strong> 中，这样，在浏览器端渲染的时候，是不会去调用 getInitialProps 的，直接通过 <strong>NEXT_DATA</strong> 中的“脱水”数据来启动页面 React 组件的渲染。</p>
<p>这样一来，如果 getInitialProps 中有调用 API 的异步操作，只在服务器端做一次，浏览器端就不用做了。</p>
<p>那么，getInitialProps 什么时候会在浏览器端调用呢？</p>
<p>当在单页应用中做页面切换的时候，比如从 Home 页切换到 Product 页，这时候完全和服务器端没关系，只能靠浏览器端自己了，Product页面的 getInitialProps 函数就会在浏览器端被调用，得到的数据用来开启页面的 React 原生生命周期过程。</p>
<p>关键点是，浏览器可能会直接访问 /home 或者 /product，也可能通过网页切换访问这两个页面，也就是说 Home 或者 Product 都可能被服务器端渲染，也可能完全只有浏览器端渲染，不过，这对应用开发者来说无所谓，应用开发者只要写好 getInitialProps，至于调用 getInitialProps 的时机，交给 Next.js 处理就好了。</p>
<p>你可以发明自己的服务器端框架，但很可能最后你发现，如果要做得通用性好，最后都会做到和 Next.js 一样的模式上来。</p>
<p>值得一提的是，getInitialProps 返回的应该是“纯数据”，也就是不要返回一个定制类的实例。比如，有一个类 Foo 有一个成员函数 bar，不要在 getInitialProps 返回一个 Foo 实例。不然，经过“脱水”和“注水”过程，网页组件获得的那个“Foo 实例”不再是你想的那个 Foo 实例了，它变成了一个纯粹的数据，不会包含成员函数 bar的。</p>
<h2 id="八、React-的未来（1）：-拥抱异步渲染"><a href="#八、React-的未来（1）：-拥抱异步渲染" class="headerlink" title="八、React 的未来（1）： 拥抱异步渲染"></a>八、React 的未来（1）： 拥抱异步渲染</h2><p><strong>同步渲染的问题</strong></p>
<p>长期以来，React 一直用的是同步渲染，这样对 React 实现非常直观方便，但是会带来性能问题。</p>
<p>假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。</p>
<p>在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 shouldComponentUpdate 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。</p>
<p><strong>异步渲染：两阶段渲染</strong></p>
<p>React Fiber 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。</p>
<p>根据 React Fiber 的设计，一个组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。</p>
<p>两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。</p>
<p>开启异步渲染，虽然我们获得了更好的感知性能，但是考虑到第一阶段的的生命周期函数可能会被重复调用，不得不对历史代码做一些调整。</p>
<blockquote>
<p>在 React v16.3 之前，render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：</p>
</blockquote>
<ul>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>componentWillMount</code></li>
<li><code>render</code></li>
</ul>
<blockquote>
<p>下图是 React v16.3 之前的完整的生命周期函数图：</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0f2d4d06575" alt="img"></p>
<p>React 官方告诫开发者，虽然目前所有的代码都可以照常使用，但是未来版本中会废弃掉，为了将来，使用 React 的程序应该快点去掉这些在第一阶段生命函数中有副作用的功能。不得不说 React 真的很够意思，提前这么久告诉大家这个事情，让大家有足够的时间去修改自己的代码。</p>
<p>一个典型的错误用例，也是我被问到做多的问题之一：为什么不在 componentWillMount 里去做AJAX？componentWillMount 可是比 componentDidMount 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？</p>
<p>首先，一个组件的 componentWillMount 比 componentDidMount 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，componentWillMount 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 componentWillMount 中做 AJAX 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 AJAX 放在 componentDidMount，因为 componentDidMount 在第二阶段，所以绝对不会多次重复调用，这才是 AJAX 合适的位置（当然，React 未来有更好的办法，在下一小节 Suspense 中可以讲到）。</p>
<p><strong>getDerivedStateFromProps</strong></p>
<blockquote>
<p>到了 React v16.3，React 干脆引入了一个新的生命周期函数 getDerivedStateFromProps，这个生命周期函数是一个 static 函数，在里面根本不能通过 this 访问到当前组件，输入只能通过参数，对组件渲染的影响只能通过返回值。没错，getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了 React v16.3，React 生命周期函数全图如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0fc08e10440" alt="img"></p>
<p>注意，上图中并包含全部React生命周期函数，在React v16发布时，还增加了一个componentDidCatch，当异常发生时，一个可以捕捉到异常的componentDidCatch就排上用场了。不过，很快React觉着这还不够，在v16.6.0又推出了一个新的捕捉异常的生命周期函数getDerivedStateFromError。</p>
<p>如果异常发生在第一阶段（render阶段），React就会调用getDerivedStateFromError，如果异常发生在第二阶段（commit阶段），React会调用componentDidCatch。这个区别也体现出两个阶段的区分对待。</p>
<p><strong>适应异步渲染的组件原则</strong></p>
<blockquote>
<p>明白了异步渲染的来龙去脉之后，开发者就应该明白，现在写代码必须要为未来的某一次 React 版本升级做好准备，当 React 开启异步渲染的时候，你的代码应该做到在 render 之前最多只能这些函数被调用：</p>
</blockquote>
<ul>
<li>构造函数</li>
<li><code>getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
</ul>
<p>幸存的这些第一阶段函数，除了构造函数，其余两个全都必须是纯函数，也就是不应该做任何有副作用的操作。</p>
<p>实际上，如果之前你的用法规范，除了 shouldComponentUpdate 不怎么使用第一阶段生命周期函数，你还会发现不怎么需要改动代码，比如 componentWillMount 中的代码移到构造函数中就可以了。但是如果用法错乱，比如滥用componentWillReceiveProps，那就不得不具体情况具体分析，从而决定这些代码移到什么位置。</p>
<p>开发者中一个普遍的误区，就是总想把任务往前提，提到靠前的生命周期函数去，就像我前面说过的在 componentWillMount 中做 AJAX。正确的做法是根据各函数的语义来放置代码，并不是越往前越好。</p>
<h2 id="九、React-的未来（2）：Suspense-带来的异步操作革命"><a href="#九、React-的未来（2）：Suspense-带来的异步操作革命" class="headerlink" title="九、React 的未来（2）：Suspense 带来的异步操作革命"></a>九、React 的未来（2）：Suspense 带来的异步操作革命</h2><p>上一节我们介绍了 Fiber 架构下的异步渲染机制，我们知道生命周期函数的修改是势在必行，那么，接下来呢？接下来 React 会有什么“大事”呢？</p>
<p>这个答案估计连 React 的核心开发者也在讨论中，不过从各种渠道信息看来，至少有两件“大事”在会在看得见的未来发生，那就是：</p>
<ul>
<li><code>Suspense</code></li>
<li><code>Hooks</code></li>
</ul>
<p>当然 React 增加的功能肯定远不止这点，将这两件“大事”在这里提出来，是因为它们对我们使用开发者的影响最大，会彻底改变我们的代码模式。</p>
<p>在写这本小册时，React 正式版是 v16.6.0，还只是 alpha 阶段，也许当你读到这本小册时，React 已经走得更远，但是你依然应该阅读这一小节，因为作为开发者你应该要明白技术演化的来龙去脉。</p>
<p>我们首先来了解 Suspense。Suspense 应用的场合就是异步数据处理，最常见的例子，就是通过 AJAX 从服务器获取数据，每一个 React 开发者都曾为这个问题纠结。</p>
<p>如果用一句话概括 Suspense 的功用，那就是：用同步的代码来实现异步操作。</p>
<p>而要理解 Suspense，我们先来体会一下 React 中做 AJAX 之类异步操作的痛苦</p>
<p><strong>React 同步操作的不足</strong></p>
<p>上一节介绍过，React 最初的设计，整个渲染过程都是同步的。同步的意思是，当一个组件开始渲染之后，就必须一口气渲染完，不能中断，对于特别庞大的组件树，这个渲染过程会很耗时，而且，这种同步处理，也会导致我们的代码比较麻烦。</p>
<p>当我们开始渲染某个组件的时候，假设这个组件需要从服务器获取数据，那么，要么由这个组件的父组件想办法拿到服务器的数据，然后通过 props 传递进来，要么就要靠这个组件自力更生来获取数据，但是，没有办法通过一次渲染完成这个过程，因为渲染过程是同步的，不可能让 React 等待这个组件调用 AJAX 获取数据之后再继续渲染。</p>
<blockquote>
<p>常用的做法，需要组件的 render 和 componentDidMount 函数配合。</p>
</blockquote>
<ul>
<li>在 componentDidMount 中使用 AJAX，在 AJAX 成功之后，通过 setState 修改自身状态，这会引发一次新的渲染过程。</li>
<li>在 render 函数中，如果 state 中没有需要的数据，就什么都不渲染或者渲染一个“正在装载”之类提示；如果 state 中已经有需要的数据，就可以正常渲染了，但这也必定是在 componentDidMount 修改了 state 之后，也就是只有在第二次渲染过程中才可以。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Foo extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">     data: null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">     if (!this.state.data) &#123;</span><br><span class="line">        return null;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        return &lt;div&gt;this.state.data&lt;/div&gt;;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">     callAPI().then(result =&gt; &#123;</span><br><span class="line">       this.setState(&#123;data: result&#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然可行，我们也照这种套路写过不少代码，但它的缺点也是很明显的。</p>
<p>组件必须要有自己的 state 和 componentDidMount 函数实现，也就不可能做成纯函数形式的组件。<br>需要两次渲染过程，第一次是 mount 引发的渲染，由 componentDidMount 触发 AJAX 然后修改 state，然后第二次渲染才真的渲染出内容。<br>代码啰嗦，十分啰嗦。</p>
<p><strong>理想中的代码形式</strong></p>
<p>而 Suspense 就是为了克服上述 React 的缺点。</p>
<p>在了解 Suspense 怎么解决这些问题之前，我们不妨自己想象一下，如果要利用 AJAX 获取数据，代码怎样写最简洁高效？</p>
<p>我先来说一说自己设想的最佳代码形式。首先，我不想写一个有状态的组件，因为通过 AJAX 获取的数据往往也就在渲染用一次，没必要存在 state 里；其次，想要使数据拿来就用，不需要经过 componentDidMount 走一圈。所以，代码最好是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;</span><br><span class="line">  const data = callAPI();</span><br><span class="line">  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>够简洁吧，可是目前的 React 版本做不到啊！</p>
<p>因为 callAPI 肯定是一个异步操作，不可能获得同步数据，无法在同步的 React 渲染过程中立足。</p>
<p>不过，现在做不到，不代表将来做不到，将来 React 会支持这样的代码形式，这也就是 Suspense。</p>
<p><strong>Suspense</strong></p>
<p>在 JsConf Iceland 2018 技术大会 上，React 的开发者展示了未来 React 会支持的新特性 Suspense，有了 Suspense，就可以在 React 中以同步的形式来写异步代码，代码形式类似下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; &#123;</span><br><span class="line">  const data = createFetcher(callAJAX).read();</span><br><span class="line">  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 React 推出 v16 的时候，就增加了一个新生命周期函数 componentDidCatch。如果某个组件定义了 componentDidCatch，那么这个组件中所有的子组件在渲染过程中抛出异常时，这个 componentDidCatch 函数就会被调用。</p>
<p>可以这么设想，componentDidCatch 就是 JavaScript 语法中的 catch，而对应的 try 覆盖所有的子组件，就像下面这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //渲染子组件</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  // componentDidCatch被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Suspense 就是巧妙利用 componentDidCatch 来实现同步形式的异步处理。</p>
<p>Suspense 提供的 createFetcher 函数会封装异步操作，当尝试从 createFetcher 返回的结果读取数据时，有两种可能：一种是数据已经就绪，那就直接返回结果；还有一种可能是异步操作还没有结束，数据没有就绪，这时候 createFetcher 会抛出一个“异常”。</p>
<p>你可能会说，抛出异常，渲染过程不就中断了吗？</p>
<p>的确会中断，不过，createFetcher 抛出的这个“异常”比较特殊，这个“异常”实际上是一个 Promise 对象，这个 Promise 对象代表的就是异步操作，操作结束时，也是数据准备好的时候。当 componentDidCatch 捕获这个 Promise 类型的“异常”时，就可以根据这个 Promise 对象的状态改变来重新渲染对应组件，第二次渲染，肯定就能够成功。</p>
<p>下面是 createFetcher 的一个简单实现方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var NO_RESULT = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">export const createFetcher = (task) =&gt; &#123;</span><br><span class="line">  let result = NO_RESULT;</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    const p = task();</span><br><span class="line"></span><br><span class="line">    p.then(res =&gt; &#123;</span><br><span class="line">      result = res;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (result === NO_RESULT) &#123;</span><br><span class="line">      throw p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，createFetcher 的参数 task 被调用应该返回一个 Promise 对象，这个对象在第一次调用时会被 throw 出去，但是，只要这个对象完结，那么 result 就有实际的值，不会再被 throw。</p>
<p>还需要一个和 createFetcher 配合的 Suspense，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Suspense extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    pending: false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error) &#123;</span><br><span class="line">    // easy way to detect Promise type</span><br><span class="line">    if (typeof error.then === &#x27;function&#x27;) &#123;</span><br><span class="line">      this.setState(&#123;pending: true&#125;);</span><br><span class="line"></span><br><span class="line">      error.then(() =&gt; this.setState(&#123;</span><br><span class="line">        pending: false</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.state.pending ? null : this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 Suspense 组件实现了 componentDidCatch，如果捕获的 error 是 Promise 类型，那就说明子组件用 createFetcher 获取异步数据了，就会等到它完结之后重设 state，引发一次新的渲染过程，因为 createFetcher 中会记录异步返回的结果，新的渲染就不会抛出异常了。</p>
<p>使用 createFetcher 和 Suspense 的示例代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const getName = () =&gt; new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;Morgan&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const fetcher = createFetcher(getName);</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;Hello &#123;fetcher()&#125;&lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const SuspenseDemo = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense&gt;</span><br><span class="line">      &lt;Greeting /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的 getName 利用 setTimeout 模拟了异步 AJAX 获取数据，第一次渲染 Greeting 组件时，会有 Promise 类型的异常抛出，被 Suspense 捕获。1 秒钟之后，当 getName 返回实际结果的时候，Suspense 会引发重新渲染，这一次 Greeting 会显示出 hello Morgan。</p>
<p>上面的 createFetcher 和 Suspense 是一个非常简陋的实现，主要用来让读者了解 Suspense 的工作原理，正式发布的 Suspense 肯定会具备更强大的功能。</p>
<p><strong>React v16.6.0 对 Suspense 的支持</strong></p>
<p>React 发布 v16.6.0 的时候，提供了 Suspense 组件，直接支持 Suspense 功能，但是还没有正式提供 createFetcher 的功能，只发布了一个独立但不稳定的 react-cache 包。这个包里的 unstable_createResource 相当于上面描述的 createFetcher。照这个命名来看，正式发布的时候这个 API 可能会叫做 createResource 而不是叫 createFetcher。</p>
<p>我们利用 React v16.6.0 和不稳定的 react-cache 来实现上述功能，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Suspense&#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;unstable_createResource as createResource&#125; from &#x27;react-cache&#x27;;</span><br><span class="line"></span><br><span class="line">const getName = () =&gt; new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;Morgan&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const resource = createResource(getName);</span><br><span class="line"></span><br><span class="line">const Greeting = () =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;hello &#123;resource.read()&#125;&lt;/div&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const SuspenseDemo = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125; &gt;</span><br><span class="line">      &lt;Greeting /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用 React 提供的 Suspense 组件，支持一个 fallback 属性，这个属性可以用于显示“装载中”界面。在上面的例子中，要等待 1 秒钟时间才得到模拟 API 的结果，这时候显示一个空白页面是肯定不合适的，在等待的这 1 秒钟里，显得就是一个“Loading…”字样。</p>
<p>很显然，需要一个最佳实践来控制 Suspense 的范围。如果我们只在组件树最顶层放一个 Suspense 组件，那么在 API 返回之前，整个页面只显示“装载中”，这样的用户体验并不好。正确的做法，是将每一个独立依赖某个 API 调用的组件用一个 Suspense 包住。</p>
<p>例如，一个页面中包括头部的 Header、左侧的导航栏 LeftPanel 和右侧的内容 Content，其中只有 Header 的渲染不依赖于 API，那么，JSX 可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;</span><br><span class="line">        &lt;LeftPanel /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;LoadingSpin /&gt;&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这样，网页首先显示 Header，然后无论 LeftPanel 还是 Content 中谁的 AJAX 首先返回结果，都可以立刻显示对应模块，而不用等待所有 AJAX 都返回才让用户看到更新。</p>
<p><strong>Suspense 带来的 React 使用模式改变</strong></p>
<p>Suspense 被推出之后，可以极大地减少异步操作代码的复杂度。</p>
<p>之前，只要有 AJAX 这样的异步操作，就必须要用两次渲染来显示 AJAX 结果，这就需要用组件的 state 来存储 AJAX 的结果，用 state 又意味着要把组件实现为一个 class。总之，我们需要做这些：</p>
<ul>
<li>实现一个 class；</li>
<li>class 中需要有 state；</li>
<li>需要实现 componentDidMount 函数；</li>
<li>render 必须要根据 this.state 来渲染不同内容。</li>
<li>有了 Suspense 之后，不需要做上面这些杂事，只要一个函数形式组件就足够了。</li>
</ul>
<p>在介绍 Redux 时，我们提到过在 Suspense 面前，Redux 的一切异步操作方案都显得繁琐，读者现在应该能够通过代码理解这一点了。</p>
<p>很可惜，目前 Suspense 还不支持服务器端渲染，当 Suspense 支持服务器端渲染的时候，那就真的会对 React 社区带来革命性影响。</p>
<p><strong>总结</strong></p>
<ul>
<li>Suspense 解决异步操作的问题；</li>
<li>有了 Supsense 之后，依赖 AJAX 的组件也可以是函数形式，不需要是 class。</li>
</ul>
<h2 id="十、函数化的-Hooks"><a href="#十、函数化的-Hooks" class="headerlink" title="十、函数化的 Hooks"></a>十、函数化的 Hooks</h2><p>React v16.7.0-alpha 中第一次引入了 Hooks 的概念，因为这是一个 alpha 版本，不算正式发布，所以，将来正式发布时 API 可能会有变化。</p>
<blockquote>
<p>Hooks 的目的，简而言之就是让开发者不需要再用 class 来实现组件</p>
</blockquote>
<p>还记得之前我们介绍的经典 Counter 组件吗？不考虑用 Redux 或者 Mobx 来管理状态的话，Counter 组件就需要把计数数据放在 state 里，要用 state，就意味着需要定义一个 class。</p>
<p>很多时候，一个简单组件也需要实现一个 class，的确是一件很烦的事，有了 Hooks 之后，事情就简单多了，我们用几个已经公开的 Hooks API 来看看如何避免写 class。</p>
<p><strong>useState</strong></p>
<blockquote>
<p>Hooks 会提供一个叫 useState 的方法，它开启了一扇新的定义 state 的门，对应 Counter 的代码可以这么写：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意看，Counter 拥有自己的“状态”，但它只是一个函数，不是 class。</p>
<p>useState 只接受一个参数，也就是 state 的初始值，它返回一个只有两个元素的数组，第一个元素就是 state 的值，第二个元素是更新 state 的函数。</p>
<p>我们利用解构赋值（destructuring assignment）把两个元素分别赋值给 count 和 setCount，相当于这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码等同于： const [count, setCount] = useState(0);</span><br><span class="line">const result = useState(0);</span><br><span class="line">const count = result[0];</span><br><span class="line">const setCount = result[1];</span><br></pre></td></tr></table></figure>

<p>利用 count 可以读取到这个 state，利用 setCount 可以更新这个 state，而且我们完全可以控制这两个变量的命名，只要高兴，你完全可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [theCount, updateCount] = useState(0);</span><br></pre></td></tr></table></figure>

<p>因为 useState 在 Counter 这个函数体中，每次 Counter 被渲染的时候，这个 useState 调用都会被执行，useState 自己肯定不是一个纯函数，因为它要区分第一次调用（组件被 mount 时）和后续调用（重复渲染时），只有第一次才用得上参数的初始值，而后续的调用就返回“记住”的 state 值。</p>
<p>读者看到这里，心里可能会有这样的疑问：如果组件中多次使用 useState 怎么办？React 如何“记住”哪个状态对应哪个变量？</p>
<p>React 是完全根据 useState 的调用顺序来“记住”状态归属的，假设组件代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  const [foo, updateFoo] = useState(&#x27;foo&#x27;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次 Counter 被渲染，都是第一次 useState 调用获得 count 和 setCount，第二次 useState 调用获得 foo 和 updateFoo（这里我故意让命名不用 set 前缀，可见函数名可以随意）。React 是渲染过程中的“上帝”，每一次渲染 Counter 都要由 React 发起，所以它有机会准备好一个内存记录，当开始执行的时候，每一次 useState 调用对应内存记录上一个位置，而且是按照顺序来记录的。React 不知道你把 useState 等 Hooks API 返回的结果赋值给什么变量，但是它也不需要知道，它只需要按照 useState 调用顺序记录就好了。</p>
<p>正因为这个原因，Hooks，千万不要在 if 语句或者 for 循环语句中使用！</p>
<p>像下面的代码，肯定会出乱子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    if (count % 2 === 0) &#123;</span><br><span class="line">        const [foo, updateFoo] = useState(&#x27;foo&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    const [bar, updateBar] = useState(&#x27;bar&#x27;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为条件判断，让每次渲染中 useState 的调用次序不一致了，于是 React 就错乱了。</p>
<p><strong>useEffect</strong></p>
<p>除了 useState，React 还提供 useEffect，用于支持组件中增加副作用的支持。</p>
<p>在 React 组件生命周期中如果要做有副作用的操作，代码放在哪里？</p>
<p>当然是放在 componentDidMount 或者 componentDidUpdate 里，但是这意味着组件必须是一个 class。</p>
<p>在 Counter 组件，如果我们想要在用户点击“+”或者“-”按钮之后把计数值体现在网页标题上，这就是一个修改 DOM 的副作用操作，所以必须把 Counter 写成 class，而且添加下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  document.title = `Count: $&#123;this.state.count&#125;`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  document.title = `Count: $&#123;this.state.count&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而有了 useEffect，我们就不用写一个 class 了，对应代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  </span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `Count: $&#123;count&#125;`;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">       &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>useEffect 的参数是一个函数，组件每次渲染之后，都会调用这个函数参数，这样就达到了 componentDidMount 和 componentDidUpdate 一样的效果。</p>
<p>虽然本质上，依然是 componentDidMount 和 componentDidUpdate 两个生命周期被调用，但是现在我们关心的不是 mount 或者 update 过程，而是“after render”事件，useEffect 就是告诉组件在“渲染完”之后做点什么事。</p>
<p>读者可能会问，现在把 componentDidMount 和 componentDidUpdate 混在了一起，那假如某个场景下我只在 mount 时做事但 update 不做事，用 useEffect 不就不行了吗？</p>
<p>其实，用一点小技巧就可以解决。useEffect 还支持第二个可选参数，只有同一 useEffect 的两次调用第二个参数不同时，第一个函数参数才会被调用，所以，如果想模拟 componentDidMount，只需要这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 这里只有mount时才被调用，相当于componentDidMount</span><br><span class="line">&#125;, [123]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的代码中，useEffect 的第二个参数是 [123]，其实也可以是任何一个常数，因为它永远不变，所以 useEffect 只在 mount 时调用第一个函数参数一次，达到了 componentDidMount 一样的效果。</p>
</blockquote>
<p><strong>useContext</strong></p>
<p>在前面介绍“提供者模式”章节我们介绍过 React 新的 Context API，这个 API 不是完美的，在多个 Context 嵌套的时候尤其麻烦。</p>
<p>比如，一段 JSX 如果既依赖于 ThemeContext 又依赖于 LanguageContext，那么按照 React Context API 应该这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        theme =&gt; (</span><br><span class="line">            &lt;LanguageContext.Cosumer&gt;</span><br><span class="line">                language =&gt; &#123;</span><br><span class="line">                    //可以使用theme和lanugage了</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/LanguageContext.Cosumer&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<p>因为 Context API 要用 render props，所以用两个 Context 就要用两次 render props，也就用了两个函数嵌套，这样的缩格看起来也的确过分了一点点。</p>
<p>使用 Hooks 的 useContext，上面的代码可以缩略为下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const theme = useContext(ThemeContext);</span><br><span class="line">const language = useContext(LanguageContext);</span><br><span class="line">// 这里就可以用theme和language了</span><br></pre></td></tr></table></figure>

<p>这个useContext把一个需要很费劲才能理解的 Context API 使用大大简化，不需要理解render props，直接一个函数调用就搞定。</p>
<p>但是，useContext也并不是完美的，它会造成意想不到的重新渲染，我们看一个完整的使用useContext的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const ThemedPage = () =&gt; &#123;</span><br><span class="line">    const theme = useContext(ThemeContext);</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">            &lt;Header color=&#123;theme.color&#125; /&gt;</span><br><span class="line">            &lt;Content color=&#123;theme.color&#125;/&gt;</span><br><span class="line">            &lt;Footer color=&#123;theme.color&#125;/&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为这个组件ThemedPage使用了useContext，它很自然成为了Context的一个消费者，所以，只要Context的值发生了变化，ThemedPage就会被重新渲染，这很自然，因为不重新渲染也就没办法重新获得theme值，但现在有一个大问题，对于ThemedPage来说，实际上只依赖于theme中的color属性，如果只是theme中的size发生了变化但是color属性没有变化，ThemedPage依然会被重新渲染，当然，我们通过给Header、Content和Footer这些组件添加shouldComponentUpdate实现可以减少没有必要的重新渲染，但是上一层的ThemedPage中的JSX重新渲染是躲不过去了。</p>
<p>说到底，useContext需要一种表达方式告诉React：“我没有改变，重用上次内容好了。”</p>
<p>希望Hooks正式发布的时候能够弥补这一缺陷。</p>
<p><strong>Hooks 带来的代码模式改变</strong></p>
<p>上面我们介绍了 useState、useEffect 和 useContext 三个最基本的 Hooks，可以感受到，Hooks 将大大简化使用 React 的代码。</p>
<p>首先我们可能不再需要 class了，虽然 React 官方表示 class 类型的组件将继续支持，但是，业界已经普遍表示会迁移到 Hooks 写法上，也就是放弃 class，只用函数形式来编写组件。</p>
<p>对于 useContext，它并没有为消除 class 做贡献，却为消除 render props 模式做了贡献。很长一段时间，高阶组件和 render props 是组件之间共享逻辑的两个武器，但如同我前面章节介绍的那样，这两个武器都不是十全十美的，现在 Hooks 的出现，也预示着高阶组件和 render props 可能要被逐步取代。</p>
<p>但读者朋友，不要觉得之前学习高阶组件和 render props 是浪费时间，相反，你只有明白 React 的使用历史，才能更好地理解 Hooks 的意义。</p>
<p>可以预测，在 Hooks 兴起之后，共享代码之间逻辑会用函数形式，而且这些函数会以 use- 前缀为约定，重用这些逻辑的方式，就是在函数形式组件中调用这些 useXXX 函数。</p>
<p>例如，我们可以写这样一个共享 Hook useMountLog，用于在 mount 时记录一个日志，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const useMountLog = (name) =&gt; &#123;</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(`$&#123;name&#125; mounted`);    </span><br><span class="line">    &#125;, [123]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何一个函数形式组件都可以直接调用这个 useMountLog 获得这个功能，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">    useMountLog(&#x27;Counter&#x27;);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对了，所有的 Hooks API 都只能在函数类型组件中调用，class 类型的组件不能用，从这点看，很显然，class 类型组件将会走向消亡。</p>
<p><strong>总结</strong></p>
<ul>
<li>Hooks 的意义就是可以淘汰 class 类型的组件；</li>
<li>Hooks 将改变重用组件逻辑的模式；</li>
<li>在未来，Hooks 将是 React 使用的主流</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/02/React-%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/">React-类组件和函数组件的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/React/">React</a></span><div class="content"><h2 id="一、类组件"><a href="#一、类组件" class="headerlink" title="一、类组件"></a>一、类组件</h2><p>类组件，顾名思义，也就是通过使用<code>ES6</code>类的编写形式去编写组件，该类必须继承<code>React.Component</code></p>
<p>如果想要访问父组件传递过来的参数，可通过<code>this.props</code>的方式去访问</p>
<p>在组件中必须实现<code>render</code>方法，在<code>return</code>中返回<code>React</code>对象，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、函数组件"><a href="#二、函数组件" class="headerlink" title="二、函数组件"></a>二、函数组件</h2><p>函数组件，顾名思义，就是通过函数编写的形式去实现一个<code>React</code>组件，是<code>React</code>中定义组件最简单的方式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数第一个参数为<code>props</code>用于接收父组件传递过来的参数</p>
<h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p>针对两种<code>React</code>组件，其区别主要分成以下几大方向：</p>
<ul>
<li>编写形式</li>
<li>状态管理</li>
<li>生命周期</li>
<li>调用方式</li>
<li>获取渲染的值</li>
</ul>
<h3 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h3><p>两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式</p>
<p>函数组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>在<code>hooks</code>出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用<code>setState</code></p>
<p>如果想要管理<code>state</code>状态，可以使用<code>useState</code>，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionalComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    );</span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>在使用<code>hooks</code>情况下，一般如果函数组件调用<code>state</code>，则需要创建一个类组件或者<code>state</code>提升到你的父组件中，然后通过<code>props</code>对象传递到子组件</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的<code>React.Component</code></p>
<p>所以，如果用到生命周期，就只能使用类组件</p>
<p>但是函数组件使用<code>useEffect</code>也能够完成替代生命周期的作用，这里给出一个简单的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionalComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述简单的例子对应类组件中的<code>componentDidMount</code>生命周期</p>
<p>如果在<code>useEffect</code>回调函数中<code>return</code>一个函数，则<code>return</code>函数会在组件卸载的时候执行，正如<code>componentWillUnmount</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionalComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"> <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;, []);</span><br><span class="line"> <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bye, World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>如果是一个函数组件，调用则是执行函数即可：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你的代码 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SayHi</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Hello, React&lt;/p &gt; </span><br><span class="line">&#125; </span><br><span class="line">// React内部 </span><br><span class="line">const result = SayHi(props) // » &lt;p&gt;Hello, React&lt;/p &gt;</span><br></pre></td></tr></table></figure>

<p>如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的<code>render</code>方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你的代码 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SayHi</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123; </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> &lt;p&gt;Hello, React&lt;/p &gt; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">// React内部 </span><br><span class="line">const instance = new SayHi(props) // » SayHi &#123;&#125; </span><br><span class="line">const result = instance.render() // » &lt;p&gt;Hello, React&lt;/p &gt;</span><br></pre></td></tr></table></figure>

<h3 id="获取渲染的值"><a href="#获取渲染的值" class="headerlink" title="获取渲染的值"></a>获取渲染的值</h3><p>首先给出一个示例</p>
<p>函数组件对应如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProfilePage</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">showMessage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Followed &#x27;</span> + props.<span class="property">user</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(showMessage, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类组件对应如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProfilePage</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Followed &#x27;</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">user</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">showMessage</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者看起来实现功能是一致的，但是在类组件中，输出<code>this.props.user</code>，<code>Props</code>在 <code>React</code>中是不可变的所以它永远不会改变，但是 <code>this</code> 总是可变的，以便您可以在 <code>render</code> 和生命周期函数中读取新版本</p>
<p>因此，如果我们的组件在请求运行时更新。<code>this.props</code> 将会改变。<code>showMessage</code>方法从“最新”的 <code>props</code> 中读取 <code>user</code></p>
<p>而函数组件，本身就不存在<code>this</code>，<code>props</code>并不发生改变，因此同样是点击，<code>alert</code>的内容仍旧是之前的内容</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>两种组件都有各自的优缺点</p>
<p>函数组件语法更短、更简单，这使得它更容易开发、理解和测试</p>
<p>而类组件也会因大量使用 <code>this</code>而让人感到困惑</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F6%2F53cca8e7873e6.jpg&amp;refer=http%3A%2F%2Fpic1.win4000.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1664449271&amp;t=4f4642aaba02226ad62910f50b366e4b)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By ChengWei</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>